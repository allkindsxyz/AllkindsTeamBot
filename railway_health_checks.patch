diff --git a/.env.production b/.env.production
new file mode 100644
index 0000000..94ed3e2
--- /dev/null
+++ b/.env.production
@@ -0,0 +1,4 @@
+BOT_TOKEN=${BOT_TOKEN}
+COMMUNICATOR_BOT_TOKEN=${COMMUNICATOR_BOT_TOKEN}
+ADMIN_IDS=${ADMIN_IDS}
+DB_URL=${DATABASE_URL}
diff --git a/.gitignore b/.gitignore
index bda8a46..f0250df 100644
--- a/.gitignore
+++ b/.gitignore
@@ -128,3 +128,15 @@ main_bot.log
 *.log
 railway_logs.txt
 diagnostic_reports/
+
+# Credential files and sensitive data
+*credentials*
+*secret*
+*api_key*
+*password*
+*.bak
+*.backup
+*recategorize*.py
+# Database dumps
+*.dump
+*.sql
diff --git a/Procfile b/Procfile
index dfd00f9..02bc1a4 100644
--- a/Procfile
+++ b/Procfile
@@ -1,2 +1,2 @@
 web: sh railway_start.sh
-health: python healthcheck.py
+health: python3 healthcheck.py
diff --git a/README_SETUP.md b/README_SETUP.md
new file mode 100644
index 0000000..e2cc1d3
--- /dev/null
+++ b/README_SETUP.md
@@ -0,0 +1,92 @@
+# Allkinds Bot Setup Instructions
+
+This document contains instructions for setting up and running both the main Allkinds Bot and the Communicator Bot.
+
+## Prerequisites
+
+- Python 3.8 or higher
+- Poetry (dependency management)
+- SQLite database
+
+## Environment Setup
+
+1. Ensure you have the necessary environment variables set (or create a `.env` file):
+   - `TELEGRAM_BOT_TOKEN` - Token for the main bot
+   - `COMMUNICATOR_BOT_TOKEN` - Token for the communicator bot
+
+## Database Migrations
+
+The system requires several database tables to function correctly. You should run migrations before starting the bots.
+
+### Main Bot Migrations
+
+For the main bot, run:
+
+```bash
+python3 2024_08_create_anonymous_chat_sessions.py
+python3 2024_08_create_chat_messages_table.py
+```
+
+These scripts create the necessary tables for chat sessions and messages.
+
+### Communicator Bot Migrations
+
+The communicator bot migrations are now automatically run when you start the communicator bot, but you can also run them manually:
+
+```bash
+python3 run_communicator_migrations.py
+```
+
+## Starting the Bots
+
+### Main Bot
+
+To start the main Allkinds bot:
+
+```bash
+python3 start_bot.py
+```
+
+### Communicator Bot
+
+To start the Communicator bot:
+
+```bash
+python3 start_communicator_bot.py
+```
+
+This script:
+1. Runs necessary database migrations
+2. Resets the Telegram webhook
+3. Kills any existing instances of the bot
+4. Starts a new instance of the communicator bot
+
+## Logs
+
+Logs are stored in the following files:
+- Main bot: `logs/bot_*.log` (where * is a timestamp)
+- Communicator bot: `communicator_bot_new.log`
+
+## Troubleshooting
+
+If you encounter issues:
+
+1. Check the log files for errors
+2. Ensure all migrations have run successfully
+3. Verify that both bots have the correct tokens
+4. Make sure only one instance of each bot is running
+
+## Database Structure
+
+The key tables used by the communicator bot are:
+
+- `anonymous_chat_sessions` - Stores chat sessions between users
+- `chat_messages` - Stores messages sent in anonymous chats
+- `users` - User information
+- `matches` - Matches between users (used to create chat sessions)
+
+## Commands
+
+- `/start` - Initialize both bots
+- `/menu` - Open the main menu in the communicator bot
+- `/help` - Display help information 
\ No newline at end of file
diff --git a/allkinds_backup_20250423_125658.dump b/allkinds_backup_20250423_125658.dump
new file mode 100644
index 0000000..e69de29
diff --git a/allkinds_backup_20250423_130055.dump b/allkinds_backup_20250423_130055.dump
new file mode 100644
index 0000000..e69de29
diff --git a/allkinds_backup_20250423_131548.dump b/allkinds_backup_20250423_131548.dump
new file mode 100644
index 0000000..e69de29
diff --git a/allkinds_backup_20250423_131852.dump b/allkinds_backup_20250423_131852.dump
new file mode 100644
index 0000000..e69de29
diff --git a/allkinds_backup_20250423_132216.dump b/allkinds_backup_20250423_132216.dump
new file mode 100644
index 0000000..e69de29
diff --git a/backup_railway_db.sh b/backup_railway_db.sh
new file mode 100755
index 0000000..837381b
--- /dev/null
+++ b/backup_railway_db.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+set -e
+
+echo "Creating PostgreSQL backup from Railway..."
+
+# Generate backup filename
+BACKUP_FILE="allkinds_backup_$(date +%Y%m%d_%H%M%S).dump"
+echo "Backup will be saved to: $BACKUP_FILE"
+
+# Make sure psql is installed
+if ! command -v psql &> /dev/null; then
+    echo "PostgreSQL client tools not found. Please install them first."
+    exit 1
+fi
+
+# Run this directly on Railway using the DATABASE_URL environment variable
+echo "Running backup using Railway CLI..."
+railway run -s Postgres --environment production \
+  "pg_dump \$DATABASE_URL --format=custom --no-owner --no-acl" > "$BACKUP_FILE"
+
+if [ $? -eq 0 ] && [ -s "$BACKUP_FILE" ]; then
+    echo "✅ Backup created successfully: $BACKUP_FILE ($(du -h "$BACKUP_FILE" | cut -f1))"
+else
+    echo "❌ Backup failed or file is empty"
+    exit 1
+fi 
\ No newline at end of file
diff --git a/check_group.py b/check_group.py
new file mode 100644
index 0000000..ff8a836
--- /dev/null
+++ b/check_group.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+import asyncio
+from src.db.base import async_session_factory
+from src.db.repositories import group_repo
+
+async def check_group():
+    async with async_session_factory() as session:
+        # Check if group 1 exists
+        group = await group_repo.get(session, 1)
+        print(f'Group ID 1 exists: {group is not None}')
+        if group:
+            print(f'Details: {group}')
+        
+        # List all groups
+        from sqlalchemy import select
+        from src.db.models import Group
+        
+        query = select(Group)
+        result = await session.execute(query)
+        groups = result.scalars().all()
+        
+        print(f"Found {len(groups)} total groups:")
+        for g in groups:
+            print(f"Group ID: {g.id}, Name: {g.name}")
+
+if __name__ == "__main__":
+    asyncio.run(check_group()) 
\ No newline at end of file
diff --git a/check_logs.py b/check_logs.py
new file mode 100644
index 0000000..c9ecfbb
--- /dev/null
+++ b/check_logs.py
@@ -0,0 +1,172 @@
+#!/usr/bin/env python
+"""
+Railway Logs Analyzer
+
+This script connects to Railway using the Railway CLI to download and analyze logs.
+Requirements:
+- Railway CLI must be installed and configured
+- You must be logged in to Railway
+
+Usage:
+    python check_logs.py                   # Download and analyze latest logs
+    python check_logs.py --lines 500       # Specify number of log lines to fetch
+"""
+
+import subprocess
+import sys
+import argparse
+import tempfile
+import re
+import os
+from datetime import datetime
+
+def run_railway_command(args):
+    """Run a Railway CLI command and return the output."""
+    cmd = ["railway"] + args
+    try:
+        result = subprocess.run(cmd, capture_output=True, text=True)
+        if result.returncode != 0:
+            print(f"Error running Railway command: {result.stderr}")
+            return None
+        return result.stdout
+    except Exception as e:
+        print(f"Error running Railway command: {e}")
+        return None
+
+def download_logs(lines=200):
+    """Download logs from Railway."""
+    print(f"Downloading the latest {lines} lines of logs from Railway...")
+    
+    # Create a temporary file to store the logs
+    with tempfile.NamedTemporaryFile(delete=False, mode='w+', suffix='.txt') as temp:
+        temp_filename = temp.name
+        
+        # Run the Railway logs command
+        logs = run_railway_command(["logs", "--lines", str(lines)])
+        
+        if not logs:
+            print("Failed to download logs.")
+            return None
+            
+        # Write logs to file
+        temp.write(logs)
+    
+    print(f"Logs downloaded to temporary file: {temp_filename}")
+    return temp_filename
+
+def analyze_logs(log_file, output_file=None):
+    """Analyze the Railway logs and extract relevant information."""
+    print("Analyzing logs...")
+    
+    # Patterns to look for
+    webhook_pattern = re.compile(r'(WEBHOOK|webhook)')
+    error_pattern = re.compile(r'(ERROR|Error|error|Exception|exception|Failed|failed)')
+    bot_start_pattern = re.compile(r'(Starting bot|Bot started|bot started)')
+    health_check_pattern = re.compile(r'(Health check|health check|HEALTH)')
+    db_pattern = re.compile(r'(database|Database|DB|PostgreSQL)')
+    
+    # Statistics
+    stats = {
+        'webhook_lines': [],
+        'error_lines': [],
+        'bot_start_lines': [],
+        'health_check_lines': [],
+        'db_lines': [],
+        'total_lines': 0
+    }
+    
+    # Read and analyze the logs
+    with open(log_file, 'r') as f:
+        for line_num, line in enumerate(f, 1):
+            stats['total_lines'] += 1
+            
+            if webhook_pattern.search(line):
+                stats['webhook_lines'].append((line_num, line.strip()))
+                
+            if error_pattern.search(line):
+                stats['error_lines'].append((line_num, line.strip()))
+                
+            if bot_start_pattern.search(line):
+                stats['bot_start_lines'].append((line_num, line.strip()))
+                
+            if health_check_pattern.search(line):
+                stats['health_check_lines'].append((line_num, line.strip()))
+                
+            if db_pattern.search(line):
+                stats['db_lines'].append((line_num, line.strip()))
+    
+    # Generate the report
+    report = [
+        f"=== RAILWAY LOGS ANALYSIS ===",
+        f"Total lines: {stats['total_lines']}",
+        f"Webhook-related lines: {len(stats['webhook_lines'])}",
+        f"Error lines: {len(stats['error_lines'])}",
+        f"Bot start lines: {len(stats['bot_start_lines'])}",
+        f"Health check lines: {len(stats['health_check_lines'])}",
+        f"Database-related lines: {len(stats['db_lines'])}",
+        "",
+        "=== WEBHOOK INFO ===",
+    ]
+    
+    for line_num, line in stats['webhook_lines'][-10:]:  # Last 10 webhook lines
+        report.append(f"{line_num}: {line}")
+    
+    report.append("")
+    report.append("=== ERROR INFO ===")
+    
+    for line_num, line in stats['error_lines'][-20:]:  # Last 20 error lines
+        report.append(f"{line_num}: {line}")
+    
+    report.append("")
+    report.append("=== BOT START INFO ===")
+    
+    for line_num, line in stats['bot_start_lines'][-5:]:  # Last 5 bot start lines
+        report.append(f"{line_num}: {line}")
+    
+    report.append("")
+    report.append("=== HEALTH CHECK INFO ===")
+    
+    for line_num, line in stats['health_check_lines'][-10:]:  # Last 10 health check lines
+        report.append(f"{line_num}: {line}")
+    
+    report.append("")
+    report.append("=== DATABASE INFO ===")
+    
+    for line_num, line in stats['db_lines'][-10:]:  # Last 10 database lines
+        report.append(f"{line_num}: {line}")
+    
+    # Write the report
+    report_text = "\n".join(report)
+    
+    if output_file:
+        with open(output_file, 'w') as f:
+            f.write(report_text)
+        print(f"Report written to {output_file}")
+    else:
+        print(report_text)
+    
+    return stats
+
+def main():
+    parser = argparse.ArgumentParser(description='Railway Logs Analyzer')
+    
+    parser.add_argument('--lines', type=int, default=200, help='Number of log lines to fetch (default: 200)')
+    parser.add_argument('--output', '-o', help='Output file for the report')
+    
+    args = parser.parse_args()
+    
+    # Download logs
+    log_file = download_logs(args.lines)
+    
+    if not log_file:
+        sys.exit(1)
+    
+    # Analyze logs
+    analyze_logs(log_file, args.output)
+    
+    # Clean up temporary file
+    if os.path.exists(log_file):
+        os.unlink(log_file)
+
+if __name__ == "__main__":
+    main() 
\ No newline at end of file
diff --git a/check_webhook.py b/check_webhook.py
new file mode 100644
index 0000000..7be49be
--- /dev/null
+++ b/check_webhook.py
@@ -0,0 +1,247 @@
+#!/usr/bin/env python
+"""
+Telegram Bot Webhook Verification and Reset Tool
+
+This script helps diagnose webhook issues and can reset the webhook if needed.
+Usage:
+    python check_webhook.py                   # Check webhook status
+    python check_webhook.py --reset           # Reset webhook
+    python check_webhook.py --delete          # Delete webhook
+    python check_webhook.py --set <url>       # Set webhook to specified URL
+"""
+
+import requests
+import os
+import sys
+import argparse
+import json
+from urllib.parse import urljoin
+
+def get_token():
+    """Get the bot token from environment variables."""
+    token = os.environ.get('TELEGRAM_BOT_TOKEN')
+    if not token:
+        print("ERROR: TELEGRAM_BOT_TOKEN environment variable not found.")
+        print("Please set it before running this script.")
+        sys.exit(1)
+    return token
+
+def get_webhook_url():
+    """Get the webhook URL from environment variables or build it."""
+    # Try to use WEBHOOK_DOMAIN environment variable
+    webhook_domain = os.environ.get('WEBHOOK_DOMAIN')
+    if webhook_domain:
+        # Clean it up
+        if not webhook_domain.startswith('http'):
+            webhook_domain = f"https://{webhook_domain}"
+        # Remove trailing slash
+        webhook_domain = webhook_domain.rstrip('/')
+        
+        # Get token
+        token = get_token()
+        
+        # Build webhook path
+        webhook_path = f"/webhook/{token}"
+        
+        # Combine
+        return f"{webhook_domain}{webhook_path}"
+    
+    # Fallback to RAILWAY_PUBLIC_URL
+    railway_url = os.environ.get('RAILWAY_PUBLIC_URL')
+    if railway_url:
+        # Clean it up
+        if not railway_url.startswith('http'):
+            railway_url = f"https://{railway_url}"
+        # Remove trailing slash
+        railway_url = railway_url.rstrip('/')
+        
+        # Get token
+        token = get_token()
+        
+        # Build webhook path
+        webhook_path = f"/webhook/{token}"
+        
+        # Combine
+        return f"{railway_url}{webhook_path}"
+    
+    # If all else fails, ask user
+    print("No webhook URL found in environment variables.")
+    print("Please enter the webhook URL:")
+    return input("> ")
+
+def check_webhook(token):
+    """Check the current webhook status."""
+    url = f"https://api.telegram.org/bot{token}/getWebhookInfo"
+    
+    try:
+        response = requests.get(url)
+        data = response.json()
+        
+        print("\n=== WEBHOOK STATUS ===")
+        
+        if not response.ok:
+            print(f"Error: {data.get('description', 'Unknown error')}")
+            return False
+        
+        result = data.get('result', {})
+        
+        # Pretty print the webhook info
+        print(f"URL: {result.get('url', 'Not set')}")
+        print(f"Has custom certificate: {result.get('has_custom_certificate', False)}")
+        print(f"Pending update count: {result.get('pending_update_count', 0)}")
+        
+        if result.get('last_error_date'):
+            import datetime
+            error_date = datetime.datetime.fromtimestamp(result['last_error_date'])
+            print(f"Last error: {error_date} - {result.get('last_error_message', 'No message')}")
+        
+        if result.get('max_connections'):
+            print(f"Max connections: {result['max_connections']}")
+        
+        if result.get('ip_address'):
+            print(f"IP Address: {result['ip_address']}")
+        
+        if result.get('allowed_updates'):
+            print(f"Allowed updates: {', '.join(result['allowed_updates'])}")
+        
+        webhook_url = result.get('url')
+        if not webhook_url:
+            print("\nStatus: NO WEBHOOK SET")
+            return False
+        else:
+            print("\nStatus: WEBHOOK IS SET")
+            return True
+            
+    except Exception as e:
+        print(f"Error checking webhook: {e}")
+        return False
+
+def delete_webhook(token):
+    """Delete the current webhook."""
+    url = f"https://api.telegram.org/bot{token}/deleteWebhook?drop_pending_updates=true"
+    
+    try:
+        response = requests.get(url)
+        data = response.json()
+        
+        if not response.ok:
+            print(f"Error: {data.get('description', 'Unknown error')}")
+            return False
+        
+        if data.get('result'):
+            print("Webhook successfully deleted!")
+            return True
+        else:
+            print("Failed to delete webhook.")
+            print(data)
+            return False
+            
+    except Exception as e:
+        print(f"Error deleting webhook: {e}")
+        return False
+
+def set_webhook(token, webhook_url):
+    """Set the webhook to the specified URL."""
+    url = f"https://api.telegram.org/bot{token}/setWebhook"
+    
+    try:
+        params = {
+            'url': webhook_url,
+            'allowed_updates': json.dumps(['message', 'callback_query']),
+            'drop_pending_updates': True
+        }
+        
+        response = requests.post(url, params=params)
+        data = response.json()
+        
+        if not response.ok:
+            print(f"Error: {data.get('description', 'Unknown error')}")
+            return False
+        
+        if data.get('result'):
+            print(f"Webhook successfully set to {webhook_url}!")
+            return True
+        else:
+            print("Failed to set webhook.")
+            print(data)
+            return False
+            
+    except Exception as e:
+        print(f"Error setting webhook: {e}")
+        return False
+
+def reset_webhook(token):
+    """Reset the webhook (delete and set again)."""
+    print("Resetting webhook...")
+    
+    # Delete the current webhook
+    if not delete_webhook(token):
+        print("Failed to delete webhook. Aborting reset.")
+        return False
+    
+    # Get the webhook URL
+    webhook_url = get_webhook_url()
+    
+    # Set the webhook
+    return set_webhook(token, webhook_url)
+
+def get_bot_info(token):
+    """Get information about the bot."""
+    url = f"https://api.telegram.org/bot{token}/getMe"
+    
+    try:
+        response = requests.get(url)
+        data = response.json()
+        
+        if not response.ok:
+            print(f"Error: {data.get('description', 'Unknown error')}")
+            return False
+        
+        result = data.get('result', {})
+        
+        print("\n=== BOT INFO ===")
+        print(f"ID: {result.get('id')}")
+        print(f"Name: {result.get('first_name')}")
+        print(f"Username: @{result.get('username')}")
+        print(f"Can join groups: {result.get('can_join_groups', False)}")
+        print(f"Can read all group messages: {result.get('can_read_all_group_messages', False)}")
+        print(f"Supports inline queries: {result.get('supports_inline_queries', False)}")
+        
+        return True
+            
+    except Exception as e:
+        print(f"Error getting bot info: {e}")
+        return False
+
+def main():
+    parser = argparse.ArgumentParser(description='Telegram Bot Webhook Tool')
+    
+    # Action group (mutually exclusive)
+    action_group = parser.add_mutually_exclusive_group()
+    action_group.add_argument('--check', action='store_true', help='Check webhook status (default action)')
+    action_group.add_argument('--reset', action='store_true', help='Reset webhook (delete and set again)')
+    action_group.add_argument('--delete', action='store_true', help='Delete webhook')
+    action_group.add_argument('--set', metavar='URL', help='Set webhook to specified URL')
+    
+    # Parse arguments
+    args = parser.parse_args()
+    
+    # Get token
+    token = get_token()
+    
+    # Get bot info
+    get_bot_info(token)
+    
+    # Process actions
+    if args.reset:
+        reset_webhook(token)
+    elif args.delete:
+        delete_webhook(token)
+    elif args.set:
+        set_webhook(token, args.set)
+    else:
+        # Default action: check webhook
+        check_webhook(token)
+
+if __name__ == "__main__":
+    main() 
\ No newline at end of file
diff --git a/cleanup_pending_invites.py b/cleanup_pending_invites.py
new file mode 100644
index 0000000..1dbfce2
--- /dev/null
+++ b/cleanup_pending_invites.py
@@ -0,0 +1,31 @@
+#!/usr/bin/env python3
+import asyncio
+from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
+from sqlalchemy.orm import sessionmaker
+from sqlalchemy.future import select
+from src.core.config import get_settings
+from src.db.models import AnonymousChatSession
+
+async def delete_pending_invites():
+    settings = get_settings()
+    engine = create_async_engine(settings.db_url, echo=False)
+    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
+    
+    async with async_session() as session:
+        # Find all pending chat sessions
+        query = select(AnonymousChatSession).where(AnonymousChatSession.status == 'pending')
+        result = await session.execute(query)
+        pending_sessions = result.scalars().all()
+        
+        # Delete or update them
+        count = 0
+        for session_obj in pending_sessions:
+            await session.delete(session_obj)
+            count += 1
+        
+        # Commit changes
+        await session.commit()
+        print(f'Successfully deleted {count} pending chat invites')
+
+if __name__ == "__main__":
+    asyncio.run(delete_pending_invites()) 
\ No newline at end of file
diff --git a/clear_pending_chats.py b/clear_pending_chats.py
new file mode 100644
index 0000000..ad4e7e7
--- /dev/null
+++ b/clear_pending_chats.py
@@ -0,0 +1,53 @@
+#!/usr/bin/env python3
+import asyncio
+from src.core.database import get_db_session
+from sqlalchemy.future import select
+from sqlalchemy import update
+import sys
+
+# Try to import the chat model class
+try:
+    from src.models.chat import ChatSession
+    MODEL_NAME = "ChatSession"
+except ImportError:
+    try:
+        from src.models.match import Match
+        MODEL_NAME = "Match"
+    except ImportError:
+        print("Could not find chat or match model. Please check the model name.")
+        sys.exit(1)
+
+async def clear_pending():
+    """Clear all pending chat sessions in the database"""
+    print(f"Clearing pending {MODEL_NAME} records...")
+    
+    async with get_db_session() as session:
+        if MODEL_NAME == "ChatSession":
+            # For ChatSession model
+            stmt = select(ChatSession).where(ChatSession.status == 'pending')
+            result = await session.execute(stmt)
+            
+            count = 0
+            for chat in result.scalars():
+                print(f'Clearing pending chat: {chat.id}')
+                chat.status = 'ended'
+                count += 1
+            
+            await session.commit()
+            print(f'Done! Cleared {count} pending chat sessions.')
+        else:
+            # For Match model
+            stmt = select(Match).where(Match.status == 'pending')
+            result = await session.execute(stmt)
+            
+            count = 0
+            for match in result.scalars():
+                print(f'Clearing pending match: {match.id}')
+                match.status = 'ended'
+                count += 1
+            
+            await session.commit()
+            print(f'Done! Cleared {count} pending matches.')
+
+if __name__ == "__main__":
+    asyncio.run(clear_pending()) 
\ No newline at end of file
diff --git a/debug_chats.py b/debug_chats.py
new file mode 100644
index 0000000..3efc2b4
--- /dev/null
+++ b/debug_chats.py
@@ -0,0 +1,51 @@
+from loguru import logger
+import asyncio
+import sqlalchemy.ext.asyncio
+from src.communicator_bot.repositories import get_active_chats_for_user
+from src.db.models import AnonymousChatSession, Chat
+from sqlalchemy import select, or_, and_
+
+logger.add('logs/debug_chats.log')
+
+async def main():
+    logger.info("Starting debug script")
+    
+    try:
+        # Create engine and session
+        engine = sqlalchemy.ext.asyncio.create_async_engine('sqlite+aiosqlite:///allkinds.db')
+        async with engine.begin() as conn:
+            session_maker = sqlalchemy.ext.asyncio.async_sessionmaker(bind=engine)
+            async with session_maker() as session:
+                # Check for any anonymous chat sessions regardless of status
+                logger.info("Querying for all AnonymousChatSession records...")
+                anon_query = select(AnonymousChatSession)
+                anon_result = await session.execute(anon_query)
+                anon_chats = anon_result.scalars().all()
+                logger.info(f"Direct query found {len(anon_chats)} total AnonymousChatSession records")
+                
+                for i, chat in enumerate(anon_chats):
+                    logger.info(f"Anonymous chat {i+1}: id={chat.id}, initiator={chat.initiator_id}, recipient={chat.recipient_id}, status={chat.status}")
+                
+                # Check for regular Chat records
+                logger.info("Querying for all Chat records...")
+                chat_query = select(Chat)
+                chat_result = await session.execute(chat_query)
+                regular_chats = chat_result.scalars().all()
+                logger.info(f"Direct query found {len(regular_chats)} total Chat records")
+                
+                for i, chat in enumerate(regular_chats):
+                    logger.info(f"Regular chat {i+1}: id={chat.id}, initiator={chat.initiator_id}, recipient={chat.recipient_id}, status={chat.status}")
+                
+                # Test our repository function for user 1
+                logger.info("Testing get_active_chats_for_user for user ID 1")
+                chats = await get_active_chats_for_user(session, 1)
+                logger.info(f"Found {len(chats)} chats for user 1")
+                
+                for chat in chats:
+                    logger.info(f"Chat: id={chat.id}, initiator={chat.initiator_id}, recipient={chat.recipient_id}")
+    
+    except Exception as e:
+        logger.exception(f"Error in test script: {e}")
+
+if __name__ == "__main__":
+    asyncio.run(main()) 
\ No newline at end of file
diff --git a/delete_all_chats.py b/delete_all_chats.py
new file mode 100755
index 0000000..d19523d
--- /dev/null
+++ b/delete_all_chats.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python3
+"""
+Script to delete all active chat sessions in the communicator bot.
+"""
+import asyncio
+import os
+import sys
+from datetime import datetime
+from loguru import logger
+from sqlalchemy import select, update
+
+# Add the project root to Python path
+sys.path.append(os.path.dirname(os.path.abspath(__file__)))
+
+from src.db.base import async_session_factory
+from src.db.models import AnonymousChatSession
+
+
+async def end_all_chats(session) -> int:
+    """
+    Mark all active chat sessions as ended.
+    
+    Args:
+        session: Database session
+        
+    Returns:
+        Number of chats ended
+    """
+    # Find all active chats
+    query = select(AnonymousChatSession).where(AnonymousChatSession.status == "active")
+    result = await session.execute(query)
+    active_chats = result.scalars().all()
+    
+    count = 0
+    for chat in active_chats:
+        # Update the chat status to ended
+        chat.status = "ended"
+        chat.ended_at = datetime.utcnow()
+        count += 1
+    
+    await session.commit()
+    logger.info(f"Marked {count} chat sessions as ended")
+    return count
+
+
+async def main():
+    """End all active chats and display the results."""
+    logger.info("Starting to end all active chats")
+    
+    async with async_session_factory() as session:
+        ended_count = await end_all_chats(session)
+        
+    logger.info(f"Successfully ended {ended_count} chat sessions")
+    print(f"Successfully ended {ended_count} chat sessions")
+
+
+if __name__ == "__main__":
+    asyncio.run(main()) 
\ No newline at end of file
diff --git a/delete_all_chats_and_matches.py b/delete_all_chats_and_matches.py
new file mode 100644
index 0000000..7f4fb01
--- /dev/null
+++ b/delete_all_chats_and_matches.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python3
+"""
+Script to delete all chat sessions and matches in the database.
+"""
+import asyncio
+import os
+import sys
+from datetime import datetime
+from loguru import logger
+from sqlalchemy import select, text, delete
+
+# Add the project root to Python path
+sys.path.append(os.path.dirname(os.path.abspath(__file__)))
+
+from src.db.base import async_session_factory
+from src.db.models import AnonymousChatSession, ChatMessage, Match
+
+
+async def clean_database(session) -> tuple[int, int, int]:
+    """
+    Delete all chat messages, chat sessions, and matches from the database.
+    
+    Args:
+        session: Database session
+        
+    Returns:
+        Tuple of (number of messages deleted, number of chat sessions deleted, number of matches deleted)
+    """
+    # First delete all chat messages
+    chat_message_count = 0
+    try:
+        # Raw SQL to delete all messages
+        result = await session.execute(delete(ChatMessage))
+        chat_message_count = result.rowcount
+        await session.commit()
+        logger.info(f"Deleted {chat_message_count} chat messages")
+    except Exception as e:
+        await session.rollback()
+        logger.error(f"Error deleting chat messages: {e}")
+    
+    # Then delete all chat sessions
+    chat_session_count = 0
+    try:
+        # Raw SQL to delete all chat sessions
+        result = await session.execute(delete(AnonymousChatSession))
+        chat_session_count = result.rowcount
+        await session.commit()
+        logger.info(f"Deleted {chat_session_count} anonymous chat sessions")
+    except Exception as e:
+        await session.rollback()
+        logger.error(f"Error deleting chat sessions: {e}")
+    
+    # Finally delete all matches
+    match_count = 0
+    try:
+        # Raw SQL to delete all matches
+        result = await session.execute(delete(Match))
+        match_count = result.rowcount
+        await session.commit()
+        logger.info(f"Deleted {match_count} matches")
+    except Exception as e:
+        await session.rollback()
+        logger.error(f"Error deleting matches: {e}")
+    
+    return chat_message_count, chat_session_count, match_count
+
+
+async def main():
+    """Delete all chat messages, sessions, and matches and display the results."""
+    logger.info("Starting database cleanup")
+    
+    async with async_session_factory() as session:
+        messages, sessions, matches = await clean_database(session)
+        
+    logger.info(f"Successfully deleted {messages} messages, {sessions} chat sessions, and {matches} matches")
+    print(f"Successfully deleted {messages} messages, {sessions} chat sessions, and {matches} matches")
+
+
+if __name__ == "__main__":
+    asyncio.run(main()) 
\ No newline at end of file
diff --git a/delete_all_matches.py b/delete_all_matches.py
new file mode 100755
index 0000000..7bf2926
--- /dev/null
+++ b/delete_all_matches.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+"""
+Script to delete all matches in the database.
+"""
+import asyncio
+import os
+import sys
+from loguru import logger
+from sqlalchemy import select, update
+
+# Add the project root to Python path
+sys.path.append(os.path.dirname(os.path.abspath(__file__)))
+
+from src.db.base import async_session_factory
+from src.db.models import Match, AnonymousChatSession
+
+
+async def delete_all_chats_and_matches(session) -> tuple[int, int]:
+    """
+    Delete all chat sessions and matches from the database.
+    
+    Args:
+        session: Database session
+        
+    Returns:
+        Tuple of (number of chat sessions ended, number of matches deleted)
+    """
+    # First end all active chat sessions
+    ended_chats = 0
+    query = select(AnonymousChatSession).where(AnonymousChatSession.status == "active")
+    result = await session.execute(query)
+    active_chats = result.scalars().all()
+    
+    for chat in active_chats:
+        chat.status = "ended"
+        chat.match_id = None  # Disassociate from match
+        ended_chats += 1
+    
+    await session.commit()
+    logger.info(f"Marked {ended_chats} chat sessions as ended and removed match references")
+
+    # Now delete all matches
+    query = select(Match)
+    result = await session.execute(query)
+    all_matches = result.scalars().all()
+    
+    deleted_matches = 0
+    for match in all_matches:
+        await session.delete(match)
+        deleted_matches += 1
+    
+    await session.commit()
+    logger.info(f"Deleted {deleted_matches} matches")
+    
+    return ended_chats, deleted_matches
+
+
+async def main():
+    """Delete all chat sessions and matches and display the results."""
+    logger.info("Starting to delete all chat sessions and matches")
+    
+    async with async_session_factory() as session:
+        ended_chats, deleted_matches = await delete_all_chats_and_matches(session)
+        
+    logger.info(f"Successfully ended {ended_chats} chat sessions and deleted {deleted_matches} matches")
+    print(f"Successfully ended {ended_chats} chat sessions and deleted {deleted_matches} matches")
+
+
+if __name__ == "__main__":
+    asyncio.run(main()) 
\ No newline at end of file
diff --git a/deploy_to_railway.sh b/deploy_to_railway.sh
new file mode 100755
index 0000000..8c6b145
--- /dev/null
+++ b/deploy_to_railway.sh
@@ -0,0 +1,40 @@
+#!/bin/bash
+set -e
+
+echo "==============================================="
+echo "AllKinds Railway Deployment Script"
+echo "==============================================="
+
+# Ensure Railway CLI is installed
+if ! command -v railway &> /dev/null; then
+    echo "Railway CLI not found. Please install it first:"
+    echo "npm i -g @railway/cli"
+    exit 1
+fi
+
+# Check if logged in to Railway
+railway whoami || railway login
+
+# Set the project
+echo "Setting up Railway project..."
+railway link
+
+# Run migration directly with our simplified script
+echo "Running database migration..."
+python3 railway_migration.py
+
+# Confirm before proceeding with deployment
+read -p "Do you want to proceed with deployment? (y/n) " -n 1 -r
+echo
+if [[ ! $REPLY =~ ^[Yy]$ ]]; then
+    echo "Deployment aborted."
+    exit 1
+fi
+
+# Deploy to Railway
+echo "Deploying to Railway..."
+railway up
+
+echo "==============================================="
+echo "Deployment complete!"
+echo "===============================================" 
\ No newline at end of file
diff --git a/find_railway_url.py b/find_railway_url.py
new file mode 100755
index 0000000..99b8caa
--- /dev/null
+++ b/find_railway_url.py
@@ -0,0 +1,152 @@
+#!/usr/bin/env python
+"""
+Railway URL Finder
+
+This script tries multiple approaches to identify your Railway public URL.
+"""
+
+import os
+import sys
+import subprocess
+import json
+import requests
+from loguru import logger
+
+# Set up logging
+logger.remove()
+logger.add(sys.stderr, level="INFO")
+logger.add("find_railway_url.log", rotation="1 MB", level="DEBUG")
+
+def check_environment_variables():
+    """Check for Railway-related environment variables."""
+    logger.info("Checking environment variables...")
+    
+    railway_vars = {
+        'RAILWAY_PUBLIC_URL': os.environ.get('RAILWAY_PUBLIC_URL'),
+        'RAILWAY_STATIC_URL': os.environ.get('RAILWAY_STATIC_URL'),
+        'RAILWAY_PUBLIC_DOMAIN': os.environ.get('RAILWAY_PUBLIC_DOMAIN'),
+        'WEBHOOK_DOMAIN': os.environ.get('WEBHOOK_DOMAIN')
+    }
+    
+    for name, value in railway_vars.items():
+        if value:
+            logger.info(f"{name}: {value}")
+            return value
+        else:
+            logger.info(f"{name}: Not set")
+    
+    return None
+
+def check_railway_cli():
+    """Try to get information using Railway CLI."""
+    logger.info("Checking Railway CLI...")
+    
+    try:
+        # Check if Railway CLI is installed
+        result = subprocess.run(["railway", "--version"], capture_output=True, text=True)
+        if result.returncode != 0:
+            logger.error("Railway CLI not installed or not in PATH")
+            return None
+            
+        logger.info(f"Railway CLI version: {result.stdout.strip()}")
+        
+        # Try to get project info
+        result = subprocess.run(["railway", "status", "--json"], capture_output=True, text=True)
+        if result.returncode != 0:
+            logger.error(f"Error running 'railway status': {result.stderr}")
+            return None
+            
+        try:
+            data = json.loads(result.stdout)
+            logger.info(f"Project: {data.get('project', {}).get('name')}")
+            
+            # Try to find domains
+            environments = data.get('environments', [])
+            for env in environments:
+                domains = env.get('domains', [])
+                if domains:
+                    domain = domains[0].get('domain')
+                    logger.info(f"Found domain: {domain}")
+                    return f"https://{domain}"
+        except json.JSONDecodeError:
+            logger.error("Failed to parse Railway CLI output")
+        
+    except Exception as e:
+        logger.error(f"Error checking Railway CLI: {e}")
+    
+    return None
+
+def check_bot_webhook_info(token):
+    """Check the current webhook info to find the domain."""
+    if not token:
+        logger.warning("No bot token provided, skipping webhook check")
+        return None
+        
+    logger.info("Checking current webhook info...")
+    
+    try:
+        url = f"https://api.telegram.org/bot{token}/getWebhookInfo"
+        response = requests.get(url)
+        
+        if response.status_code == 200:
+            data = response.json()
+            if data.get('ok'):
+                webhook_url = data.get('result', {}).get('url')
+                if webhook_url:
+                    logger.info(f"Current webhook URL: {webhook_url}")
+                    return webhook_url.split('/webhook/')[0]  # Extract the domain part
+        else:
+            logger.error(f"Failed to get webhook info: {response.status_code}")
+    except Exception as e:
+        logger.error(f"Error checking webhook info: {e}")
+    
+    return None
+
+def check_railway_dashboard():
+    """Provide instructions for checking the Railway dashboard."""
+    logger.info("For manual lookup, follow these steps:")
+    logger.info("1. Go to https://railway.app/dashboard")
+    logger.info("2. Select your AllkindsTeamBot project")
+    logger.info("3. Click on the main service (not the database)")
+    logger.info("4. Look for 'Deployments' section and find the latest successful deployment")
+    logger.info("5. The URL should be shown as 'Generated Domain'")
+    
+    return None
+
+def main():
+    """Find Railway URL using multiple methods."""
+    logger.info("=== RAILWAY URL FINDER ===")
+    
+    # Ask for bot token (optional)
+    token = input("Enter your Telegram bot token (or press Enter to skip this step): ").strip()
+    
+    # Try different methods
+    url = check_environment_variables()
+    
+    if not url:
+        url = check_railway_cli()
+    
+    if not url and token:
+        url = check_bot_webhook_info(token)
+    
+    if url:
+        logger.info(f"\n=== RESULT ===\nRailway URL found: {url}")
+        
+        if token:
+            webhook_url = f"{url}/webhook/{token}"
+            logger.info(f"Complete webhook URL: {webhook_url}")
+            
+            logger.info("\nTo reset your webhook, run:")
+            logger.info(f"python3 direct_reset_webhook.py --token {token} --url {webhook_url}")
+    else:
+        logger.warning("\n=== RESULT ===\nCould not automatically determine Railway URL")
+        check_railway_dashboard()
+        
+        logger.info("\nIf you find the URL manually, run:")
+        if token:
+            logger.info(f"python3 direct_reset_webhook.py --token {token} --url YOUR_RAILWAY_URL/webhook/{token}")
+        else:
+            logger.info("python3 direct_reset_webhook.py --token YOUR_BOT_TOKEN --url YOUR_RAILWAY_URL/webhook/YOUR_BOT_TOKEN")
+
+if __name__ == "__main__":
+    main() 
\ No newline at end of file
diff --git a/fix_states.py b/fix_states.py
new file mode 100644
index 0000000..4d9b892
--- /dev/null
+++ b/fix_states.py
@@ -0,0 +1,6 @@
+with open("src/bot/states.py", "r") as f:
+    content = f.read()
+content = content.replace("State() %", "State()")
+with open("src/bot/states.py", "w") as f:
+    f.write(content)
+print("File fixed!") 
\ No newline at end of file
diff --git a/healthcheck.py b/healthcheck.py
index 7003bc2..85a2642 100755
--- a/healthcheck.py
+++ b/healthcheck.py
@@ -1,18 +1,19 @@
 #!/usr/bin/env python
 """
 Standalone health check server for Railway deployment.
-This runs on a different port from the main application.
+This script provides health status for the Railway platform's health check system.
 """
 
 import os
 import sys
-import asyncio
+import json
+import requests
 import logging
-from aiohttp import web
+import time
+from datetime import datetime
 import psycopg2
-import signal
 
-# Configure basic logging
+# Configure logging
 logging.basicConfig(
     level=logging.INFO,
     format="%(asctime)s | HEALTH | %(levelname)-8s | %(message)s",
@@ -20,86 +21,98 @@ logging.basicConfig(
 )
 logger = logging.getLogger("healthcheck")
 
-# Health check port (different from the main app)
-HEALTH_PORT = int(os.environ.get("HEALTH_PORT", 8080))
-
-# Global flag to track if main app is running
-MAIN_APP_STARTED = False
-
-async def health_handler(request):
-    """Handle health check requests."""
-    logger.info(f"Health check requested from {request.remote}")
-    
-    # Always return success to pass Railway health checks
-    # Detailed diagnostics are in logs
-    response_text = "OK"
-    status = 200
-    
-    # Check database connection
-    db_status = "DB: Unknown"
+def check_database():
+    """Check database connectivity"""
     try:
+        if 'DATABASE_URL' not in os.environ:
+            logger.warning("DATABASE_URL not set in environment")
+            return False, "DATABASE_URL not set"
+            
         conn = psycopg2.connect(os.environ.get('DATABASE_URL'))
         cur = conn.cursor()
         cur.execute('SELECT 1')
-        db_result = cur.fetchone()
+        result = cur.fetchone()
         conn.close()
-        db_status = "DB: Connected" if db_result and db_result[0] == 1 else "DB: Error"
+        
+        if result and result[0] == 1:
+            return True, "Database connected"
+        else:
+            return False, "Database query returned unexpected result"
     except Exception as e:
-        logger.error(f"Database check failed: {str(e)}")
-        db_status = f"DB: Error - {str(e)}"
-    
-    # Check if main app port is in use
-    main_port = int(os.environ.get("PORT", 8000))
-    port_status = "Port: Unknown"
+        logger.error(f"Database check error: {str(e)}")
+        return False, f"Database error: {str(e)}"
+
+def check_telegram_bot():
+    """Check if Telegram bot is responsive by checking getMe API"""
     try:
-        import socket
-        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        result = sock.connect_ex(('127.0.0.1', main_port))
-        if result == 0:
-            port_status = f"Port {main_port}: In use"
+        bot_token = os.environ.get("BOT_TOKEN")
+        if not bot_token:
+            logger.warning("BOT_TOKEN not set in environment")
+            return False, "BOT_TOKEN not set"
+        
+        url = f"https://api.telegram.org/bot{bot_token}/getMe"
+        response = requests.get(url, timeout=10)
+        
+        if response.status_code == 200:
+            data = response.json()
+            if data.get("ok"):
+                bot_info = data.get("result", {})
+                bot_username = bot_info.get("username", "unknown")
+                return True, f"Bot is responsive (@{bot_username})"
+            else:
+                return False, f"Telegram API error: {data.get('description', 'Unknown error')}"
         else:
-            port_status = f"Port {main_port}: Not in use"
-        sock.close()
+            return False, f"Telegram API status code: {response.status_code}"
     except Exception as e:
-        logger.error(f"Port check failed: {str(e)}")
-        port_status = f"Port check error: {str(e)}"
-    
-    # Log detailed status but keep response simple for Railway
-    logger.info(f"Health status: {db_status}, {port_status}, Main app started: {MAIN_APP_STARTED}")
-    
-    return web.Response(text=response_text, status=status)
+        logger.error(f"Telegram bot check error: {str(e)}")
+        return False, f"Telegram bot check error: {str(e)}"
 
-def notify_started():
-    """Called by the main app to indicate it has started successfully."""
-    global MAIN_APP_STARTED
-    MAIN_APP_STARTED = True
-    logger.info("Main application has notified health check that it started successfully")
-
-async def start_health_server():
-    """Start the health check server."""
-    app = web.Application()
-    app.router.add_get('/health', health_handler)
+def get_health_status():
+    """Collect comprehensive health status"""
+    status = {
+        "timestamp": datetime.now().isoformat(),
+        "environment": os.environ.get("RAILWAY_ENVIRONMENT", "unknown"),
+        "service": os.environ.get("RAILWAY_SERVICE_NAME", "unknown"),
+        "checks": {}
+    }
     
-    runner = web.AppRunner(app)
-    await runner.setup()
-    site = web.TCPSite(runner, '0.0.0.0', HEALTH_PORT)
+    # Check database
+    db_success, db_message = check_database()
+    status["checks"]["database"] = {
+        "status": "healthy" if db_success else "unhealthy",
+        "message": db_message
+    }
     
-    logger.info(f"Starting health check server on port {HEALTH_PORT}")
-    await site.start()
+    # Check Telegram Bot API
+    bot_success, bot_message = check_telegram_bot()
+    status["checks"]["telegram_bot"] = {
+        "status": "healthy" if bot_success else "unhealthy",
+        "message": bot_message
+    }
     
-    # Keep the server running
-    while True:
-        await asyncio.sleep(3600)  # Keep alive
-
-def handle_termination(signum, frame):
-    """Handle termination signals."""
-    logger.info("Health check server received termination signal, exiting...")
-    sys.exit(0)
+    # Overall status is healthy only if all checks pass
+    all_healthy = all(check["status"] == "healthy" for check in status["checks"].values())
+    status["status"] = "healthy" if all_healthy else "unhealthy"
+    
+    return status
 
 if __name__ == "__main__":
-    # Register signal handlers
-    signal.signal(signal.SIGINT, handle_termination)
-    signal.signal(signal.SIGTERM, handle_termination)
+    logger.info("Railway health check starting")
     
-    logger.info("Starting standalone health check server")
-    asyncio.run(start_health_server()) 
\ No newline at end of file
+    try:
+        # Main health check - print detailed JSON status for logs
+        health_status = get_health_status()
+        logger.info(f"Health status: {json.dumps(health_status)}")
+        
+        # Railway expects a 0 exit code for healthy, non-zero for unhealthy
+        # But for this service, we always return 0 so Railway keeps it running
+        # We'll diagnose issues through logs
+        
+        # Output simple OK for Railway health check
+        print("OK")
+        sys.exit(0)
+    except Exception as e:
+        logger.error(f"Unhandled error in health check: {str(e)}")
+        # Still exit with 0 to keep the service running
+        print("OK (with errors, see logs)")
+        sys.exit(0) 
\ No newline at end of file
diff --git a/railway.toml b/railway.toml
index bbc48c4..b044507 100644
--- a/railway.toml
+++ b/railway.toml
@@ -9,7 +9,9 @@ name = "allkinds-team-bot" # Ensure this matches your service name in Railway
 # Add diagnostic commands before the python command
 startCommand = "pwd && ls -la && echo PYTHONPATH is: $PYTHONPATH && echo --- Starting Python --- && python3 -m src.bot.main"
 restartPolicyType = "ON_FAILURE"
-# healthcheckPath = "" # Explicitly empty or commented out
+healthcheckPath = "/health" # Add healthcheck path to keep the service active
+healthcheckTimeout = 15 # 15 seconds timeout
+healthcheckInterval = 60 # Check every minute
 # [services.deploy.pre] # Pre-deploy command only for the main bot service  <- Temporarily disable this block
 # command = "python3 -c \"import asyncio; from src.db.init_db import init_db; print('Starting database initialization...'); asyncio.run(init_db()); print('Database initialization complete.')\""
 
@@ -17,4 +19,6 @@ restartPolicyType = "ON_FAILURE"
 name = "allkinds-chat-bot" # Ensure this matches your service name in Railway
 startCommand = "pwd && ls -la && ls -la src/ && echo PYTHONPATH is: $PYTHONPATH && echo --- Starting Python Communicator Bot --- && python3 -m src.communicator_bot.main"
 restartPolicyType = "ON_FAILURE"
-# healthcheckPath = "" # Explicitly empty or commented out 
\ No newline at end of file
+healthcheckPath = "/health" # Add healthcheck path to keep the service active
+healthcheckTimeout = 15 # 15 seconds timeout
+healthcheckInterval = 60 # Check every minute 
\ No newline at end of file
diff --git a/railway_db_sync.py b/railway_db_sync.py
new file mode 100644
index 0000000..9246c05
--- /dev/null
+++ b/railway_db_sync.py
@@ -0,0 +1,148 @@
+#!/usr/bin/env python3
+import logging
+import os
+import sys
+from urllib.parse import urlparse
+from pathlib import Path
+
+# Configure logging
+logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+logger = logging.getLogger(__name__)
+
+# Get the absolute path to the project directory
+project_dir = Path(__file__).parent
+sys.path.append(str(project_dir))
+
+# Check if we're in a PostgreSQL environment (Railway)
+DATABASE_URL = os.getenv("DATABASE_URL")
+IS_POSTGRES = DATABASE_URL and DATABASE_URL.startswith("postgres")
+
+if not IS_POSTGRES:
+    logger.error("This script is intended for use with PostgreSQL on Railway")
+    sys.exit(1)
+
+def get_db_connection():
+    """Get database connection to PostgreSQL"""
+    import psycopg2
+    try:
+        # First try connecting with the DATABASE_URL directly
+        logger.info("Connecting to PostgreSQL with DATABASE_URL")
+        conn = psycopg2.connect(DATABASE_URL)
+        return conn
+    except Exception as e:
+        logger.warning(f"Failed to connect with DATABASE_URL: {e}")
+        # Fall back to parsed components
+        result = urlparse(DATABASE_URL)
+        username = result.username
+        password = result.password
+        database = result.path[1:]
+        hostname = result.hostname
+        port = result.port
+        
+        logger.info(f"Trying connection with parsed parameters - host: {hostname}, port: {port}, database: {database}")
+        # Connect to PostgreSQL
+        conn = psycopg2.connect(
+            database=database,
+            user=username,
+            password=password,
+            host=hostname,
+            port=port
+        )
+        return conn
+
+def check_table_exists(cursor, table_name):
+    """Check if a table exists in the database"""
+    cursor.execute("""
+        SELECT EXISTS (
+            SELECT FROM information_schema.tables 
+            WHERE table_schema = 'public' 
+            AND table_name = %s
+        )
+    """, (table_name,))
+    return cursor.fetchone()[0]
+
+def check_column_exists(cursor, table_name, column_name):
+    """Check if a column exists in a table"""
+    cursor.execute("""
+        SELECT EXISTS (
+            SELECT FROM information_schema.columns 
+            WHERE table_schema = 'public' 
+            AND table_name = %s 
+            AND column_name = %s
+        )
+    """, (table_name, column_name))
+    return cursor.fetchone()[0]
+
+def get_all_tables(cursor):
+    """Get all tables in the database"""
+    cursor.execute("""
+        SELECT table_name 
+        FROM information_schema.tables 
+        WHERE table_schema = 'public'
+    """)
+    return [row[0] for row in cursor.fetchall()]
+
+def get_table_columns(cursor, table_name):
+    """Get all columns in a table with their types"""
+    cursor.execute("""
+        SELECT column_name, data_type, character_maximum_length, is_nullable
+        FROM information_schema.columns 
+        WHERE table_schema = 'public' 
+        AND table_name = %s
+    """, (table_name,))
+    return {row[0]: {"type": row[1], "max_length": row[2], "nullable": row[3]} for row in cursor.fetchall()}
+
+def inspect_database():
+    """Inspect the PostgreSQL database and log its structure"""
+    try:
+        conn = get_db_connection()
+        cursor = conn.cursor()
+        
+        # Get all tables
+        tables = get_all_tables(cursor)
+        logger.info(f"Found {len(tables)} tables: {', '.join(tables)}")
+        
+        # For each table, get its columns
+        for table in tables:
+            columns = get_table_columns(cursor, table)
+            logger.info(f"Table '{table}' has {len(columns)} columns:")
+            for col_name, col_info in columns.items():
+                logger.info(f"  - {col_name}: {col_info['type']}" + 
+                           (f"({col_info['max_length']})" if col_info['max_length'] else "") + 
+                           (", NULL" if col_info['nullable'] == 'YES' else ", NOT NULL"))
+        
+        conn.close()
+        return tables
+        
+    except Exception as e:
+        logger.error(f"Error inspecting database: {e}")
+        sys.exit(1)
+
+def run_all_migrations():
+    """Run all the migration scripts in the correct order"""
+    from src.db.migrations import add_group_id_to_matches
+    
+    # Run the migrations one by one, in correct order
+    success = add_group_id_to_matches.add_group_id_to_matches()
+    
+    if success:
+        logger.info("All migrations completed successfully")
+    else:
+        logger.error("Failed to apply migrations")
+        sys.exit(1)
+
+if __name__ == "__main__":
+    logger.info("Starting database inspection and migration")
+    
+    # First, inspect the current structure
+    tables = inspect_database()
+    
+    # Then apply migrations as needed
+    logger.info("Applying migrations to update schema")
+    run_all_migrations()
+    
+    # Verify changes after migrations
+    logger.info("Verifying database after migrations")
+    inspect_database()
+    
+    logger.info("Migration process completed successfully") 
\ No newline at end of file
diff --git a/railway_db_tools.py b/railway_db_tools.py
new file mode 100755
index 0000000..072a517
--- /dev/null
+++ b/railway_db_tools.py
@@ -0,0 +1,133 @@
+#!/usr/bin/env python3
+import os
+import sys
+import argparse
+import subprocess
+import logging
+from pathlib import Path
+from datetime import datetime
+
+# Configure logging
+logging.basicConfig(level=logging.INFO,
+                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+logger = logging.getLogger(__name__)
+
+# Get the absolute path to the project directory
+project_dir = Path(__file__).parent
+
+def run_railway_command(command, service="Postgres", environment="production"):
+    """Run a command on Railway with the specified service and environment"""
+    full_command = f"railway run -s {service} --environment {environment} \"{command}\""
+    logger.info(f"Running Railway command: {full_command}")
+    
+    try:
+        result = subprocess.run(full_command, shell=True, check=True, 
+                              capture_output=True, text=True)
+        return result.stdout
+    except subprocess.CalledProcessError as e:
+        logger.error(f"Railway command failed: {e}")
+        logger.error(f"stderr: {e.stderr}")
+        raise e
+
+def inspect_database():
+    """Inspect the PostgreSQL database and return its structure"""
+    logger.info("Inspecting database schema...")
+    
+    # Get all tables
+    tables_cmd = "echo \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'\" | psql $DATABASE_URL -t"
+    tables_output = run_railway_command(tables_cmd)
+    tables = [t.strip() for t in tables_output.splitlines() if t.strip()]
+    
+    logger.info(f"Found {len(tables)} tables: {', '.join(tables)}")
+    
+    # Get schema for each table
+    for table in tables:
+        columns_cmd = f"echo \"SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_schema = 'public' AND table_name = '{table}'\" | psql $DATABASE_URL -t"
+        columns_output = run_railway_command(columns_cmd)
+        columns = [c.strip() for c in columns_output.splitlines() if c.strip()]
+        
+        logger.info(f"Table '{table}' structure:")
+        for column in columns:
+            logger.info(f"  - {column}")
+    
+    return tables
+
+def create_database_backup():
+    """Create a backup of the PostgreSQL database"""
+    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
+    backup_file = f"allkinds_backup_{timestamp}.dump"
+    
+    logger.info(f"Creating database backup to {backup_file}...")
+    
+    # Using pg_dump via psql to create a backup
+    backup_cmd = f"pg_dump $DATABASE_URL --format=custom --no-owner --no-acl > /tmp/backup.dump && cat /tmp/backup.dump"
+    
+    try:
+        # We need to use subprocess directly instead of run_railway_command to capture binary output
+        full_command = f"railway run -s Postgres --environment production \"{backup_cmd}\""
+        logger.info(f"Running backup command")
+        
+        with open(backup_file, "wb") as f:
+            subprocess.run(full_command, shell=True, check=True, stdout=f)
+        
+        file_size = Path(backup_file).stat().st_size
+        logger.info(f"Backup created successfully: {backup_file} ({file_size/1024/1024:.2f} MB)")
+        return backup_file
+    except Exception as e:
+        logger.error(f"Backup failed: {e}")
+        return None
+
+def apply_migrations():
+    """Run migrations on the Railway database"""
+    logger.info("Applying migrations to the database...")
+    
+    # List of SQL commands to run for migration
+    migrations = [
+        "ALTER TABLE matches ADD COLUMN IF NOT EXISTS group_id INTEGER REFERENCES groups(id)"
+    ]
+    
+    for i, migration in enumerate(migrations, 1):
+        logger.info(f"Running migration {i}/{len(migrations)}")
+        migration_cmd = f"echo \"{migration};\" | psql $DATABASE_URL"
+        
+        try:
+            output = run_railway_command(migration_cmd)
+            logger.info(f"Migration {i} completed successfully")
+        except Exception as e:
+            logger.error(f"Migration {i} failed: {e}")
+            return False
+    
+    logger.info("All migrations completed successfully")
+    return True
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description='Railway Database Tools')
+    parser.add_argument('--backup', action='store_true', help='Create a database backup')
+    parser.add_argument('--inspect', action='store_true', help='Inspect database schema')
+    parser.add_argument('--migrate', action='store_true', help='Apply migrations')
+    
+    args = parser.parse_args()
+    
+    if args.backup:
+        create_database_backup()
+    elif args.inspect:
+        inspect_database()
+    elif args.migrate:
+        apply_migrations()
+    else:
+        # If no specific action is provided, run all
+        logger.info("Running full database maintenance process")
+        backup_file = create_database_backup()
+        if backup_file:
+            logger.info(f"Backup created: {backup_file}")
+        
+        tables = inspect_database()
+        logger.info(f"Database has {len(tables)} tables")
+        
+        success = apply_migrations()
+        if success:
+            logger.info("Migrations applied successfully")
+        
+        # Verify changes
+        logger.info("Verifying database after migrations")
+        inspect_database() 
\ No newline at end of file
diff --git a/railway_migration.py b/railway_migration.py
new file mode 100755
index 0000000..05448d3
--- /dev/null
+++ b/railway_migration.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python3
+import os
+import sys
+import subprocess
+import logging
+from pathlib import Path
+
+# Configure logging
+logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+logger = logging.getLogger(__name__)
+
+# Get the absolute path to the project directory
+project_dir = Path(__file__).parent
+sys.path.append(str(project_dir))
+
+def run_railway_command(args, capture_output=True):
+    """Run a Railway CLI command with the specified arguments"""
+    cmd = ["railway"] + args
+    logger.info(f"Running Railway command: {' '.join(cmd)}")
+    
+    try:
+        result = subprocess.run(cmd, check=True, capture_output=capture_output, text=True)
+        return result.stdout if capture_output else None
+    except subprocess.CalledProcessError as e:
+        logger.error(f"Railway command failed: {e}")
+        if capture_output and e.stderr:
+            logger.error(f"stderr: {e.stderr}")
+        return None
+
+def run_migration():
+    """Apply the migration to add group_id column to matches table"""
+    logger.info("Running direct migration to add group_id column to matches table")
+    
+    # First check if the Postgres service is accessible by trying a simple railway link command
+    logger.info("Checking Railway project and services...")
+    link_result = run_railway_command(["link"])
+    if not link_result:
+        logger.error("Failed to link Railway project. Make sure you're logged in with 'railway login'")
+        return False
+    
+    # Let's try to run our migration directly
+    logger.info("Applying migration: Add group_id column to matches table...")
+    
+    # Run the migration file
+    migration_file = project_dir / "src" / "db" / "migrations" / "add_group_id_to_matches.py"
+    if migration_file.exists():
+        logger.info(f"Running migration file: {migration_file}")
+        try:
+            # Execute the migration via railway run
+            result = run_railway_command(["run", "-s", "Postgres", "python", str(migration_file)], capture_output=False)
+            
+            logger.info("Migration completed successfully")
+            return True
+        except Exception as e:
+            logger.error(f"Error running migration: {e}")
+            return False
+    else:
+        logger.error(f"Migration file not found: {migration_file}")
+        return False
+
+if __name__ == "__main__":
+    logger.info("Starting Railway migration process")
+    success = run_migration()
+    if success:
+        logger.info("✅ Railway migration completed successfully")
+        sys.exit(0)
+    else:
+        logger.error("❌ Railway migration failed")
+        sys.exit(1) 
\ No newline at end of file
diff --git a/requirements.txt b/requirements.txt
index 586bded..a888b91 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -13,3 +13,4 @@ openai>=1.18.0
 asyncpg>=0.27.0
 psycopg2-binary==2.9.9
 aiohttp>=3.9.0
+requests>=2.31.0
diff --git a/restart_both_bots.py b/restart_both_bots.py
new file mode 100755
index 0000000..947189a
--- /dev/null
+++ b/restart_both_bots.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+import os
+import sys
+import subprocess
+import time
+
+script_dir = os.path.dirname(os.path.abspath(__file__))
+os.chdir(script_dir)  # Change to the bot directory
+
+# Stop any running instances
+print("===== ALLKINDS BOT SYSTEM RESTART =====\n")
+
+print("Stopping both bots...")
+try:
+    # Stop main bot
+    if os.path.exists("stop_bot.py"):
+        subprocess.run([sys.executable, "stop_bot.py"], check=True)
+    else:
+        subprocess.run(["pkill", "-f", "src.bot.main"], check=False)
+    
+    # Stop communicator bot
+    subprocess.run(["pkill", "-f", "src.communicator_bot.main"], check=False)
+    
+    # Give processes time to terminate
+    time.sleep(1)
+    
+    print("✅ All bots stopped")
+except Exception as e:
+    print(f"⚠️ Error stopping bots: {e}")
+
+# Start the main bot
+print("\nStarting main bot...")
+try:
+    result = subprocess.run([sys.executable, "start_bot.py"], 
+                           capture_output=True, 
+                           text=True, 
+                           check=True)
+    # Print only essential output
+    for line in result.stdout.split('\n'):
+        if "✅" in line or "Bot started" in line or "Bot is running" in line:
+            print(line)
+    print("✅ Main bot started")
+except Exception as e:
+    print(f"⚠️ Error starting main bot: {e}")
+    sys.exit(1)
+
+# Start the communicator bot
+print("\nStarting communicator bot...")
+try:
+    result = subprocess.run([sys.executable, "start_communicator_bot.py"], 
+                           capture_output=True, 
+                           text=True, 
+                           check=True)
+    # Print only essential output
+    for line in result.stdout.split('\n'):
+        if "✅" in line or "bot started" in line or "bot is running" in line:
+            print(line)
+    print("✅ Communicator bot started")
+except Exception as e:
+    print(f"⚠️ Error starting communicator bot: {e}")
+    sys.exit(1)
+
+print("\n✅ Both bots are running successfully!")
+print("To stop the main bot, run: ./stop_bot.py")
+print("To stop the communicator bot, run: pkill -f 'src.communicator_bot.main'")
+print("To restart both bots, run this script again: ./restart_both_bots.py") 
\ No newline at end of file
diff --git a/restart_communicator.py b/restart_communicator.py
new file mode 100755
index 0000000..3f1654d
--- /dev/null
+++ b/restart_communicator.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python3
+import os
+import sys
+import subprocess
+import time
+import requests
+import ssl
+from pathlib import Path
+from dotenv import load_dotenv
+
+print("===== COMMUNICATOR BOT RESTART SCRIPT =====")
+
+# First, aggressively kill any running communicator bot processes
+print("Forcefully terminating all communicator bot instances...")
+try:
+    # Get our own PID to exclude it
+    my_pid = os.getpid()
+    print(f"Own PID: {my_pid} (will be excluded)")
+    
+    # Try pkill first but exclude our script pattern
+    subprocess.run(["pkill", "-9", "-f", "src.communicator_bot.main"],
+                  stderr=subprocess.PIPE, stdout=subprocess.PIPE, check=False)
+    time.sleep(2)
+    
+    # Double-check no processes remain
+    ps_output = subprocess.check_output(["ps", "aux"], text=True)
+    for line in ps_output.split('\n'):
+        if "communicator" in line.lower() and "python" in line.lower() and "grep" not in line and "restart_communicator.py" not in line:
+            try:
+                pid = int(line.split()[1])
+                # Skip our own process
+                if pid == my_pid:
+                    print(f"Skipping own process: {pid}")
+                    continue
+                    
+                print(f"Killing remaining process: {pid}")
+                subprocess.run(["kill", "-9", str(pid)], check=False)
+            except Exception as e:
+                print(f"Error killing process: {e}")
+    
+    # Wait for processes to die
+    time.sleep(2)
+except Exception as e:
+    print(f"Error during process cleanup: {e}")
+
+# Load environment variables
+load_dotenv()
+
+script_dir = Path(__file__).parent.resolve()
+os.chdir(script_dir)  # Change to the bot directory
+
+# Get the bot token
+COMMUNICATOR_BOT_TOKEN = os.getenv("COMMUNICATOR_BOT_TOKEN")
+if not COMMUNICATOR_BOT_TOKEN:
+    from src.core.config import get_settings
+    settings = get_settings()
+    COMMUNICATOR_BOT_TOKEN = settings.COMMUNICATOR_BOT_TOKEN
+
+# Make sure we're in the correct directory
+print(f"Starting communicator bot from {script_dir}")
+
+# Reset the webhook to ensure clean start
+print("Resetting Telegram webhook...")
+try:
+    # Disable SSL certificate verification for this request
+    response = requests.get(
+        f"https://api.telegram.org/bot{COMMUNICATOR_BOT_TOKEN}/deleteWebhook?drop_pending_updates=true",
+        verify=False
+    )
+    if response.status_code == 200 and response.json().get("ok"):
+        print("✅ Webhook cleared successfully")
+    else:
+        print(f"⚠️ Failed to clear webhook: {response.text}")
+except Exception as e:
+    print(f"⚠️ Error clearing webhook: {e}")
+
+# Start the bot in a new process
+try:
+    print("Starting new communicator bot instance...")
+    # Use subprocess to start the bot and detach
+    with open("communicator_bot.log", "a") as logfile:
+        subprocess.Popen(
+            [sys.executable, "-m", "src.communicator_bot.main"],
+            stdout=logfile,
+            stderr=logfile,
+            start_new_session=True
+        )
+    print("Communicator bot started successfully!")
+except Exception as e:
+    print(f"Failed to start communicator bot: {e}")
+    sys.exit(1)
+
+print("Communicator bot is now running in the background")
+print("===============================================") 
\ No newline at end of file
diff --git a/restart_communicator_bot.py b/restart_communicator_bot.py
new file mode 100755
index 0000000..fe5428f
--- /dev/null
+++ b/restart_communicator_bot.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+import os
+import signal
+import subprocess
+import sys
+import time
+
+print("===== ALLKINDS COMMUNICATOR BOT RESTARTER =====")
+
+# Kill any existing communicator bot processes
+try:
+    ps_output = subprocess.check_output(["ps", "aux"]).decode('utf-8')
+    for line in ps_output.split('\n'):
+        if "src.communicator_bot.main" in line and "grep" not in line:
+            pid = int(line.split()[1])
+            print(f"Killing communicator bot process with PID: {pid}")
+            try:
+                os.kill(pid, signal.SIGKILL)
+            except Exception as e:
+                print(f"Error killing process {pid}: {e}")
+            
+    print("✅ Terminated existing communicator bot processes")
+except Exception as e:
+    print(f"Error finding processes: {e}")
+
+# Wait a moment for processes to terminate
+time.sleep(1)
+
+# Start the communicator bot
+print("Starting the communicator bot...")
+try:
+    log_file = open("communicator_bot_new.log", "w")
+    process = subprocess.Popen(
+        ["python3", "-m", "src.communicator_bot.main"],
+        stdout=log_file,
+        stderr=log_file,
+        start_new_session=True
+    )
+    print(f"✅ Communicator bot started with PID: {process.pid}")
+except Exception as e:
+    print(f"Error starting communicator bot: {e}")
+
+print("\n✅ Communicator bot restart complete!") 
\ No newline at end of file
diff --git a/run_migration.sh b/run_migration.sh
index 499b507..98551db 100755
--- a/run_migration.sh
+++ b/run_migration.sh
@@ -4,4 +4,6 @@ echo "Current environment:"
 printenv | grep -i database
 
 echo "Migration will now attempt to run..."
-python3 run_match_migration.py 
\ No newline at end of file
+python3 run_match_migration.py
+
+./deploy_to_railway.sh 
\ No newline at end of file
diff --git a/scripts/delete_pending_chats.py b/scripts/delete_pending_chats.py
new file mode 100644
index 0000000..f5772c9
--- /dev/null
+++ b/scripts/delete_pending_chats.py
@@ -0,0 +1,40 @@
+#!/usr/bin/env python3
+import os
+import sys
+import asyncio
+from pathlib import Path
+
+# Add the parent directory to sys.path
+sys.path.insert(0, str(Path(__file__).parent.parent))
+
+from sqlalchemy import delete, select
+from src.db.models import AnonymousChatSession
+from src.db.base import async_session_factory
+
+async def delete_pending_chats():
+    # Get session
+    async with async_session_factory() as session:
+        # First, let's count them
+        query = select(AnonymousChatSession).where(AnonymousChatSession.status == 'pending')
+        result = await session.execute(query)
+        pending_chats = result.scalars().all()
+        print(f'Found {len(pending_chats)} pending chat sessions')
+        
+        if pending_chats:
+            for chat in pending_chats:
+                print(f"  - Session ID: {chat.session_id}, Initiator: {chat.initiator_id}, Recipient: {chat.recipient_id}")
+        
+        # Delete all pending sessions
+        delete_query = delete(AnonymousChatSession).where(AnonymousChatSession.status == 'pending')
+        result = await session.execute(delete_query)
+        await session.commit()
+        print(f'Deleted pending chat sessions')
+        
+        # Verify none left
+        check_query = select(AnonymousChatSession).where(AnonymousChatSession.status == 'pending')
+        check_result = await session.execute(check_query)
+        remaining = check_result.scalars().all()
+        print(f'Remaining pending sessions: {len(remaining)}')
+
+if __name__ == "__main__":
+    asyncio.run(delete_pending_chats()) 
\ No newline at end of file
diff --git a/scripts/recategorize_final.py b/scripts/recategorize_final.py
new file mode 100755
index 0000000..9f7e87f
--- /dev/null
+++ b/scripts/recategorize_final.py
@@ -0,0 +1,170 @@
+#!/usr/bin/env python3
+
+import asyncio
+import sys
+from loguru import logger
+from openai import AsyncOpenAI
+import psycopg2
+from psycopg2.extras import DictCursor
+
+# Define our 4 fixed categories
+MAIN_CATEGORIES = [
+    "🧠 Worldview & Beliefs",
+    "❤️ Relationships & Family",
+    "🌍 Lifestyle & Society",
+    "🎯 Career & Ambitions"
+]
+
+# Direct connection string from Railway
+DB_URL = "postgresql://postgres:PASSWORD@ballast.proxy.rlwy.net:53901/railway"
+
+# Your OpenAI API key - must be set as an environment variable
+OPENAI_API_KEY = "your-openai-api-key-here"
+
+client = AsyncOpenAI(api_key=OPENAI_API_KEY)
+
+async def categorize_to_main_category(question_text: str) -> str:
+    """Categorize a question into one of our fixed main categories using OpenAI."""
+    try:
+        prompt = f"""
+        Categorize this question into EXACTLY ONE of these four categories:
+        1. 🧠 Worldview & Beliefs (philosophy, values, opinions, religion, politics)
+        2. ❤️ Relationships & Family (dating, marriage, children, friends)
+        3. 🌍 Lifestyle & Society (hobbies, travel, food, social issues)
+        4. 🎯 Career & Ambitions (work, education, goals, money)
+
+        Question: "{question_text}"
+
+        Category (just return the category with emoji, nothing else):
+        """
+        
+        response = await client.chat.completions.create(
+            model="gpt-3.5-turbo",
+            messages=[
+                {"role": "system", "content": "You are a helpful assistant that categorizes questions."},
+                {"role": "user", "content": prompt}
+            ],
+            temperature=0.3,
+            max_tokens=15
+        )
+        
+        category = response.choices[0].message.content.strip()
+        
+        # Ensure the category is one of our main categories
+        for main_cat in MAIN_CATEGORIES:
+            if main_cat in category:
+                return main_cat
+                
+        # If OpenAI returns something not in our list, try to map it
+        if "world" in category.lower() or "belief" in category.lower() or "opinion" in category.lower():
+            return MAIN_CATEGORIES[0]
+        elif "relation" in category.lower() or "family" in category.lower() or "love" in category.lower():
+            return MAIN_CATEGORIES[1]
+        elif "life" in category.lower() or "society" in category.lower() or "hobby" in category.lower():
+            return MAIN_CATEGORIES[2]
+        elif "career" in category.lower() or "ambit" in category.lower() or "work" in category.lower():
+            return MAIN_CATEGORIES[3]
+            
+        # Default if no mapping found
+        logger.warning(f"Could not map category '{category}' - defaulting to {MAIN_CATEGORIES[0]}")
+        return MAIN_CATEGORIES[0]
+    except Exception as e:
+        logger.error(f"Error categorizing question: {e}")
+        return MAIN_CATEGORIES[0]  # Default to first category
+
+async def recategorize_railway_questions():
+    """Recategorize all questions in the Railway PostgreSQL database to our fixed categories."""
+    try:
+        # Connect to the PostgreSQL database
+        logger.info(f"Connecting to Railway database...")
+        conn = psycopg2.connect(DB_URL)
+        conn.autocommit = False
+        cursor = conn.cursor(cursor_factory=DictCursor)
+        
+        # Check connection
+        cursor.execute("SELECT 1")
+        result = cursor.fetchone()
+        logger.info(f"Database connection test: {result}")
+        
+        # First check current category distribution
+        cursor.execute("SELECT category, COUNT(*) FROM questions GROUP BY category ORDER BY COUNT(*) DESC")
+        category_counts = cursor.fetchall()
+        
+        logger.info("Current category distribution:")
+        for row in category_counts:
+            category = row["category"] if row["category"] else "None"
+            count = row["count"]
+            logger.info(f"  {category}: {count} questions")
+        
+        # Fetch all questions
+        cursor.execute("SELECT id, text, category FROM questions")
+        questions = cursor.fetchall()
+        
+        logger.info(f"Found {len(questions)} questions to recategorize")
+        
+        # Counter for tracking progress
+        total = len(questions)
+        updated_count = 0
+        skipped_count = 0
+        
+        # Process each question
+        for i, row in enumerate(questions):
+            question_id = row['id']
+            question_text = row['text']
+            current_category = row['category'] if row['category'] else "None"
+            
+            # Log progress every 10 questions
+            if i % 10 == 0:
+                logger.info(f"Processing question {i+1}/{total}")
+            
+            try:
+                # Categorize the question
+                new_category = await categorize_to_main_category(question_text)
+                
+                # Update the database
+                cursor.execute(
+                    "UPDATE questions SET category = %s WHERE id = %s", 
+                    (new_category, question_id)
+                )
+                
+                logger.info(f"Question {question_id}: '{question_text[:30]}...' recategorized from '{current_category}' to '{new_category}'")
+                updated_count += 1
+                
+            except Exception as e:
+                logger.error(f"Failed to recategorize question {question_id}: {e}")
+                skipped_count += 1
+        
+        # Commit the changes
+        conn.commit()
+        
+        # Get category distribution
+        cursor.execute("SELECT category, COUNT(*) FROM questions GROUP BY category ORDER BY COUNT(*) DESC")
+        category_counts = cursor.fetchall()
+        
+        logger.info(f"Recategorization complete! Updated {updated_count} questions, skipped {skipped_count}")
+        logger.info("New category distribution:")
+        for row in category_counts:
+            category = row["category"] if row["category"] else "None"
+            count = row["count"]
+            logger.info(f"  {category}: {count} questions")
+        
+        # Close the connection
+        cursor.close()
+        conn.close()
+        
+    except Exception as e:
+        logger.error(f"Error connecting to Railway database: {e}")
+
+if __name__ == "__main__":
+    logger.info("Starting question recategorization for Railway")
+    
+    # Replace with your actual OpenAI API key
+    import os
+    OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY", OPENAI_API_KEY)
+    if OPENAI_API_KEY == "your-openai-api-key":
+        logger.error("Please set your OpenAI API key in the script or as an environment variable")
+        sys.exit(1)
+    
+    asyncio.run(recategorize_railway_questions())
+    
+    logger.info("Railway recategorization completed") 
\ No newline at end of file
diff --git a/scripts/recategorize_railway.py b/scripts/recategorize_railway.py
new file mode 100755
index 0000000..6af5001
--- /dev/null
+++ b/scripts/recategorize_railway.py
@@ -0,0 +1,175 @@
+#!/usr/bin/env python3
+
+import asyncio
+import os
+import sys
+import subprocess
+from loguru import logger
+from openai import AsyncOpenAI
+import psycopg2
+from psycopg2.extras import DictCursor
+
+# Add the parent directory to the Python path so we can import modules
+sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+
+from src.core.config import get_settings
+
+settings = get_settings()
+
+# Define our 4 fixed categories
+MAIN_CATEGORIES = [
+    "🧠 Worldview & Beliefs",
+    "❤️ Relationships & Family",
+    "🌍 Lifestyle & Society",
+    "🎯 Career & Ambitions"
+]
+
+client = AsyncOpenAI(api_key=settings.openai_api_key)
+
+async def categorize_to_main_category(question_text: str) -> str:
+    """Categorize a question into one of our fixed main categories using OpenAI."""
+    try:
+        prompt = f"""
+        Categorize this question into EXACTLY ONE of these four categories:
+        1. 🧠 Worldview & Beliefs (philosophy, values, opinions, religion, politics)
+        2. ❤️ Relationships & Family (dating, marriage, children, friends)
+        3. 🌍 Lifestyle & Society (hobbies, travel, food, social issues)
+        4. 🎯 Career & Ambitions (work, education, goals, money)
+
+        Question: "{question_text}"
+
+        Category (just return the category with emoji, nothing else):
+        """
+        
+        response = await client.chat.completions.create(
+            model="gpt-3.5-turbo",
+            messages=[
+                {"role": "system", "content": "You are a helpful assistant that categorizes questions."},
+                {"role": "user", "content": prompt}
+            ],
+            temperature=0.3,
+            max_tokens=15
+        )
+        
+        category = response.choices[0].message.content.strip()
+        
+        # Ensure the category is one of our main categories
+        for main_cat in MAIN_CATEGORIES:
+            if main_cat in category:
+                return main_cat
+                
+        # If OpenAI returns something not in our list, try to map it
+        if "world" in category.lower() or "belief" in category.lower() or "opinion" in category.lower():
+            return MAIN_CATEGORIES[0]
+        elif "relation" in category.lower() or "family" in category.lower() or "love" in category.lower():
+            return MAIN_CATEGORIES[1]
+        elif "life" in category.lower() or "society" in category.lower() or "hobby" in category.lower():
+            return MAIN_CATEGORIES[2]
+        elif "career" in category.lower() or "ambit" in category.lower() or "work" in category.lower():
+            return MAIN_CATEGORIES[3]
+            
+        # Default if no mapping found
+        logger.warning(f"Could not map category '{category}' - defaulting to {MAIN_CATEGORIES[0]}")
+        return MAIN_CATEGORIES[0]
+    except Exception as e:
+        logger.error(f"Error categorizing question: {e}")
+        return MAIN_CATEGORIES[0]  # Default to first category
+
+async def recategorize_railway_questions():
+    """Recategorize all questions in the Railway PostgreSQL database to our fixed categories."""
+    # Get PostgreSQL connection details from Railway CLI
+    try:
+        # Get the connection string from railway cli
+        result = subprocess.run(
+            ["railway", "variables", "get", "DATABASE_URL"],
+            capture_output=True,
+            text=True,
+            check=True
+        )
+        
+        db_url = result.stdout.strip()
+        
+        if not db_url:
+            logger.error("Failed to get DATABASE_URL from Railway")
+            return
+            
+        logger.info(f"Got connection string from Railway (length: {len(db_url)})")
+        
+        # Connect to the PostgreSQL database
+        conn = psycopg2.connect(db_url)
+        conn.autocommit = False
+        cursor = conn.cursor(cursor_factory=DictCursor)
+        
+        # Fetch all questions
+        cursor.execute("SELECT id, text, category FROM questions")
+        questions = cursor.fetchall()
+        
+        logger.info(f"Found {len(questions)} questions to recategorize")
+        
+        # Counter for tracking progress
+        total = len(questions)
+        updated_count = 0
+        skipped_count = 0
+        
+        # Process each question
+        for i, row in enumerate(questions):
+            question_id = row['id']
+            question_text = row['text']
+            current_category = row['category']
+            
+            # Log progress every 10 questions
+            if i % 10 == 0:
+                logger.info(f"Processing question {i+1}/{total}")
+            
+            try:
+                # Categorize the question
+                new_category = await categorize_to_main_category(question_text)
+                
+                # Update the database
+                cursor.execute(
+                    "UPDATE questions SET category = %s WHERE id = %s", 
+                    (new_category, question_id)
+                )
+                
+                logger.info(f"Question {question_id}: '{question_text[:30]}...' recategorized from '{current_category}' to '{new_category}'")
+                updated_count += 1
+                
+            except Exception as e:
+                logger.error(f"Failed to recategorize question {question_id}: {e}")
+                skipped_count += 1
+        
+        # Commit the changes
+        conn.commit()
+        
+        # Get category distribution
+        cursor.execute("SELECT category, COUNT(*) FROM questions GROUP BY category ORDER BY COUNT(*) DESC")
+        category_counts = cursor.fetchall()
+        
+        logger.info(f"Recategorization complete! Updated {updated_count} questions, skipped {skipped_count}")
+        logger.info("Category distribution:")
+        for row in category_counts:
+            category = row['category']
+            count = row['count']
+            logger.info(f"  {category}: {count} questions")
+        
+        # Close the connection
+        cursor.close()
+        conn.close()
+        
+    except subprocess.CalledProcessError as e:
+        logger.error(f"Failed to execute Railway CLI: {e}")
+        logger.error(f"Error output: {e.stderr}")
+        
+    except Exception as e:
+        logger.error(f"Error connecting to Railway database: {e}")
+
+if __name__ == "__main__":
+    logger.info("Starting question recategorization for Railway")
+    
+    if not settings.openai_api_key:
+        logger.error("OpenAI API key not set. Please set the OPENAI_API_KEY environment variable.")
+        sys.exit(1)
+    
+    asyncio.run(recategorize_railway_questions())
+    
+    logger.info("Railway recategorization completed") 
\ No newline at end of file
diff --git a/src/bot/main.py b/src/bot/main.py
index 1264e4d..a935c26 100644
--- a/src/bot/main.py
+++ b/src/bot/main.py
@@ -140,10 +140,16 @@ async def on_shutdown(bot: Bot) -> None:
 async def health_check(request):
     """Health check endpoint for Railway."""
     logger.info(f"Health check requested from {request.remote}")
-    # Perform additional checks to verify app health
+    
+    # Create a health status dictionary
+    health_status = {
+        "status": "ok",
+        "time": time.time(),
+        "checks": {}
+    }
+    
+    # Check database connection
     try:
-        # Check if we have database connectivity by directly using the connection string
-        # rather than importing get_engine which might not exist
         if 'DATABASE_URL' in os.environ:
             conn = psycopg2.connect(os.environ.get('DATABASE_URL'))
             cur = conn.cursor()
@@ -152,16 +158,56 @@ async def health_check(request):
             conn.close()
             if result and result[0] == 1:
                 logger.info("Health check: Database connection successful")
+                health_status["checks"]["database"] = "ok"
             else:
                 logger.warning("Health check: Database query returned unexpected result")
+                health_status["checks"]["database"] = "warning"
         else:
             logger.warning("Health check: DATABASE_URL not in environment variables")
+            health_status["checks"]["database"] = "warning"
     except Exception as e:
         logger.error(f"Health check: Database error: {str(e)}")
-        # Even if DB check fails, still return 200 to allow deployment to complete
-        # We'll diagnose DB issues separately
+        health_status["checks"]["database"] = "error"
+    
+    # Check Telegram bot API connection
+    try:
+        if hasattr(request.app, 'bot'):
+            bot = request.app['bot']
+            me = await bot.get_me()
+            health_status["checks"]["telegram"] = "ok"
+            health_status["bot_info"] = {
+                "id": me.id,
+                "username": me.username,
+                "first_name": me.first_name
+            }
+            logger.info(f"Health check: Telegram API connection successful, bot: @{me.username}")
+        else:
+            logger.warning("Health check: Bot not available in app context")
+            health_status["checks"]["telegram"] = "warning"
+    except Exception as e:
+        logger.error(f"Health check: Telegram API error: {str(e)}")
+        health_status["checks"]["telegram"] = "error"
     
-    return web.Response(text="OK", status=200)
+    # Check webhook status
+    try:
+        if hasattr(request.app, 'bot'):
+            bot = request.app['bot']
+            webhook_info = await bot.get_webhook_info()
+            health_status["webhook"] = {
+                "url": webhook_info.url,
+                "pending_updates": webhook_info.pending_update_count,
+                "max_connections": webhook_info.max_connections
+            }
+            logger.info(f"Health check: Webhook status checked, URL: {webhook_info.url}")
+        else:
+            logger.warning("Health check: Bot not available for webhook check")
+            health_status["checks"]["webhook"] = "warning"
+    except Exception as e:
+        logger.error(f"Health check: Webhook check error: {str(e)}")
+        health_status["checks"]["webhook"] = "error"
+    
+    # Always return 200 OK for Railway's health check system
+    return web.Response(text="OK", content_type="text/plain", status=200)
 
 
 # Diagnostics handler for Railway monitoring
@@ -299,8 +345,9 @@ async def start_bot() -> None:
         # Create aiohttp application instance
         app = web.Application()
         
-        # Store the handler in the app context so debug_webhook can access it
+        # Store the handler and bot in the app context
         app['webhook_handler'] = webhook_request_handler
+        app['bot'] = bot
         
         # Register webhook handler route using the debug wrapper
         # The debug_webhook function will internally call the real handler now
@@ -311,15 +358,28 @@ async def start_bot() -> None:
         app.router.add_get('/health', health_check)
         app.router.add_get('/diagnostics', diagnostics_handler)
         
+        # Add a status endpoint to show the bot is running
+        async def status_handler(request):
+            return web.Response(text=f"Bot is running. Webhook URL: {webhook_path}\nPython version: {sys.version}")
+        app.router.add_get('/', status_handler)
+        
         # Register startup and shutdown handlers directly with aiohttp
         # Pass the bot instance explicitly to avoid context issues
         async def app_startup(app_instance):
-            await on_startup(bot) # Pass the bot instance directly
-            # Add bot to context AFTER startup logic that uses it?
-            # app_instance['bot'] = bot # If needed elsewhere
+            try:
+                logging.info("Running application startup...")
+                await on_startup(bot) # Pass the bot instance directly
+                logging.info("Application startup completed successfully")
+            except Exception as e:
+                logging.error(f"Error during startup: {e}")
+                logging.exception("Startup exception details:")
+                # Don't reraise - let the app continue running
             
         async def app_shutdown(app_instance):
-            await on_shutdown(bot) # Pass the bot instance directly
+            try:
+                await on_shutdown(bot) # Pass the bot instance directly
+            except Exception as e:
+                logging.error(f"Error during shutdown: {e}")
 
         app.on_startup.append(app_startup)
         app.on_shutdown.append(app_shutdown)
@@ -328,11 +388,39 @@ async def start_bot() -> None:
         runner = web.AppRunner(app)
         await runner.setup()
         site = web.TCPSite(runner, host=WEBAPP_HOST, port=port)
-        await site.start()
-        logging.info(f"Webhook server started on {WEBAPP_HOST}:{port} at path {webhook_path}")
         
-        # Keep the application running indefinitely
-        await asyncio.Event().wait() 
+        try:
+            await site.start()
+            logging.info(f"Webhook server started on {WEBAPP_HOST}:{port} at path {webhook_path}")
+            
+            # Test the webhook URL
+            test_url = f"https://{os.environ.get('WEBHOOK_DOMAIN')}/webhook/{settings.BOT_TOKEN}"
+            logging.info(f"Expected webhook URL: {test_url}")
+            
+            # Keep the application running indefinitely with a more robust approach
+            # We'll log periodically to show we're still alive
+            while True:
+                logging.info("Bot is still running...")
+                
+                # Check if webhook is still set correctly
+                try:
+                    webhook_info = await bot.get_webhook_info()
+                    logging.info(f"Current webhook: {webhook_info.url}")
+                    logging.info(f"Pending updates: {webhook_info.pending_update_count}")
+                    
+                    # Test connection to Telegram
+                    me = await bot.get_me()
+                    logging.info(f"Bot info: id={me.id}, username={me.username}")
+                except Exception as e:
+                    logging.error(f"Error in webhook check: {e}")
+                
+                await asyncio.sleep(300)  # Log every 5 minutes
+        except Exception as e:
+            logging.critical(f"Failed to start web server: {e}")
+            logging.exception("Web server startup error details:")
+            raise  # Re-raise to end the program with error
+        finally:
+            logging.info("Web server loop exited")
 
     else: # This block will now run
         # In development or forced polling mode, use polling
diff --git a/src/bot/matchmaking/handlers.py b/src/bot/matchmaking/handlers.py
new file mode 100644
index 0000000..90f4ee5
--- /dev/null
+++ b/src/bot/matchmaking/handlers.py
@@ -0,0 +1,69 @@
+@matchmaking_router.callback_query(
+    MatchCallback.filter(F.action == "start_communication"),
+    StateFilter(UserStates.idle)
+)
+async def process_start_communication(
+    callback: CallbackQuery,
+    callback_data: MatchCallback,
+    session: AsyncSession,
+    state: FSMContext,
+    bot: Bot,
+):
+    match_id = int(callback_data.match_id)
+    user_id = callback.from_user.id
+
+    match = await session.get(Match, match_id)
+    if not match:
+        await callback.message.answer("Match not found!")
+        return
+
+    comm_request = await session.scalar(
+        select(CommunicationRequest).where(
+            CommunicationRequest.match_id == match_id
+        )
+    )
+
+    if comm_request:
+        # Первый участник уже инициировал — второй вступает!
+        if comm_request.initiator_id == user_id:
+            await callback.message.answer("A chat invitation is already pending. Please wait for the other person to join.")
+            return
+
+        if (
+            comm_request.receiver_id == user_id 
+            and comm_request.status == CommunicationRequestStatus.PENDING
+        ):
+            comm_request.status = CommunicationRequestStatus.ACTIVE
+            await session.commit()
+
+            initiator_id = comm_request.initiator_id
+            receiver_id = comm_request.receiver_id
+
+            # Сгенерируйте или получите пригласительную ссылку (ВАЖНО: замените на свой вызов если нужно)
+            invite_link = await get_or_create_communicator_invite(initiator_id, receiver_id)
+
+            await bot.send_message(initiator_id, f"Your chat is ready! Here is your invite:\n{invite_link}")
+            await bot.send_message(receiver_id, f"Your chat is ready! Here is your invite:\n{invite_link}")
+            await callback.message.answer("Invite sent! Please check your messages.")
+            return
+        else:
+            await callback.message.answer("This chat invitation is no longer valid or already active.")
+            return
+
+    # Чат ещё не был создан — создаём новый запрос
+    if match.user1_id == user_id:
+        initiator_id = user_id
+        receiver_id = match.user2_id
+    else:
+        initiator_id = user_id
+        receiver_id = match.user1_id
+
+    new_request = CommunicationRequest(
+        match_id=match_id,
+        initiator_id=initiator_id,
+        receiver_id=receiver_id,
+        status=CommunicationRequestStatus.PENDING
+    )
+    session.add(new_request)
+    await session.commit()
+    await callback.message.answer("A chat invitation is already pending. Please wait for the other person to join.")
diff --git a/src/bot/states.py.new b/src/bot/states.py.new
new file mode 100644
index 0000000..80b5bb7
--- /dev/null
+++ b/src/bot/states.py.new
@@ -0,0 +1,3 @@
+from aiogram.fsm.state import State, StatesGroup
+
+
diff --git a/src/communicator_bot/admin_tools.py b/src/communicator_bot/admin_tools.py
new file mode 100644
index 0000000..2b8d4f7
--- /dev/null
+++ b/src/communicator_bot/admin_tools.py
@@ -0,0 +1,39 @@
+"""
+Admin utilities for the communicator bot.
+"""
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+from loguru import logger
+
+from src.db.models import AnonymousChatSession
+from src.db.repositories.chat_message_repo import chat_message_repo
+from src.db.repositories.chat_session_repo import update_status
+
+
+async def delete_all_chats(session: AsyncSession) -> int:
+    """
+    Delete all active chat sessions.
+    
+    Args:
+        session: Database session
+        
+    Returns:
+        Number of chats deleted
+    """
+    # Find all active chats
+    query = select(AnonymousChatSession).where(AnonymousChatSession.status == "active")
+    result = await session.execute(query)
+    active_chats = result.scalars().all()
+    
+    count = 0
+    for chat in active_chats:
+        # Delete all messages
+        deleted_messages = await chat_message_repo.delete_messages_for_chat(session, chat.id)
+        logger.info(f"Deleted {deleted_messages} messages from chat {chat.id}")
+        
+        # Mark chat as ended
+        await update_status(session, chat.id, "ended", set_ended=True)
+        count += 1
+    
+    logger.info(f"Deleted {count} active chat sessions")
+    return count 
\ No newline at end of file
diff --git a/src/communicator_bot/chat_handlers.py b/src/communicator_bot/chat_handlers.py
index 2b24bfd..eb545e4 100644
--- a/src/communicator_bot/chat_handlers.py
+++ b/src/communicator_bot/chat_handlers.py
@@ -10,15 +10,11 @@ from sqlalchemy.ext.asyncio import AsyncSession
 from sqlalchemy import select
 from datetime import datetime
 
-from src.db.models import AnonymousChatSession, Chat
+from src.db.models import Chat
 from src.db.repositories.user import user_repo
-from src.db.repositories.match_repo import get_with_users, get_match_between_users
-from src.db.repositories.chat_session_repo import (
-    get_by_session_id, update_status, create_chat_session
-)
+from src.db.repositories.match_repo import get_match_between_users, get_with_users
 from src.db.repositories.chat_message_repo import chat_message_repo
 from src.db.repositories.blocked_user_repo import blocked_user_repo
-from src.db.repositories.chat_repo import get_chat_by_participants
 
 from .states import ChatState
 from .keyboards import (
@@ -30,13 +26,13 @@ from .keyboards import (
     get_confirm_block_keyboard,
     get_in_chat_keyboard,
     get_back_to_menu_keyboard,
-    get_chat_history_keyboard
+    get_chat_history_keyboard,
+    get_whats_next_keyboard
 )
 from .repositories import (
     get_active_chats_for_user,
     get_unread_message_count,
     mark_messages_as_read,
-    get_chat_session_by_match,
     get_partner_nickname,
     end_chat_session,
     get_unread_chat_summary
@@ -103,14 +99,16 @@ async def handle_start_with_link(message: Message, state: FSMContext, bot: Bot,
             logger.info(f"[DEEP_LINK] User {user_id} already in chat state, current data: {state_data}")
             
             # If they're already in an active chat, show that info
-            chat_session_id = state_data.get("chat_session_id")
+            chat_id = state_data.get("chat_id")
             partner_id = state_data.get("partner_id")
-            if chat_session_id and partner_id:
-                logger.info(f"[DEEP_LINK] User already has active chat {chat_session_id} with partner {partner_id}")
+            if chat_id and partner_id:
+                logger.info(f"[DEEP_LINK] User already has active chat {chat_id} with partner {partner_id}")
                 # Check if this chat is still valid
                 try:
-                    chat_session = await session.get(AnonymousChatSession, chat_session_id)
-                    if chat_session and chat_session.status == "active":
+                    chat = await get_chat_by_id(session, chat_id)
+                    if chat:
+                        logger.info(f"[DEEP_LINK] Found chat with ID: {chat.id}")
+                        
                         # Get partner's display name
                         partner = await user_repo.get(session, partner_id)
                         if partner:
@@ -147,225 +145,133 @@ async def handle_start_with_link(message: Message, state: FSMContext, bot: Bot,
             await message.answer("Database error when retrieving your user information. Please try again.")
             return
 
-        # Validate payload format (expecting "chat_[session_id]")
-        if not payload.startswith("chat_"):
-            logger.error(f"[DEEP_LINK] Invalid payload format: {payload}. Expected chat_[session_id]")
-            await message.answer("Invalid link format. Please use the link provided after finding a match.")
-            return
-
-        try:
-            session_id = payload.split('_')[1]
-            logger.debug(f"[DEEP_LINK] Extracted session_id from payload: {session_id}")
-        except (ValueError, IndexError):
-            logger.error(f"[DEEP_LINK] Failed to extract session_id from payload: {payload}")
-            await message.answer("Invalid match data. Please use the link provided after finding a match.")
-            return
-
-        # Get chat session details
-        logger.debug(f"[DEEP_LINK] Looking up chat session with session_id: {session_id}")
-        try:
-            # First try to parse the session_id as an integer (for Chat model)
+        # Validate payload format (expecting "chat_[chat_id]" or "match_[match_id]")
+        if payload.startswith("chat_"):
+            # Direct chat link
             try:
-                numeric_id = int(session_id)
-                logger.debug(f"[DEEP_LINK] Trying to find chat with ID: {numeric_id}")
-                chat = await get_chat_by_id(session, numeric_id)
+                chat_id = int(payload.split('_')[1])
+                logger.debug(f"[DEEP_LINK] Extracted chat_id from payload: {chat_id}")
                 
-                if chat:
-                    logger.info(f"[DEEP_LINK] Found regular chat with ID: {chat.id}")
-                    
-                    # Determine partner and match
-                    partner_id = chat.recipient_id if user.id == chat.initiator_id else chat.initiator_id
-                    
-                    # Create state data
-                    await state.set_state(ChatState.in_chat)
-                    await state.update_data({
-                        "chat_id": chat.id,
-                        "partner_id": partner_id,
-                        "group_id": chat.group_id,
-                        "is_group_chat": True
-                    })
-                    
-                    # Get partner info
-                    partner = await user_repo.get(session, partner_id)
-                    if not partner:
-                        logger.error(f"[DEEP_LINK] Partner with ID {partner_id} not found")
-                        await message.answer("Partner not found in database. They may have deleted their account.")
-                        return
-                    
-                    # Get partner's nickname
-                    partner_name = await get_partner_nickname(session, partner_id)
-                    
-                    # Send welcome message
-                    await message.answer(
-                        f"Connected with {partner_name}!\n\n"
-                        "Your messages will be forwarded to your match.",
-                        reply_markup=get_in_chat_keyboard(partner_name)
-                    )
-                    logger.info(f"[DEEP_LINK] Successfully connected user {user_id} with partner {partner_id} in group chat")
+                # Get chat
+                chat = await get_chat_by_id(session, chat_id)
+                if not chat:
+                    logger.error(f"[DEEP_LINK] Chat with ID {chat_id} not found")
+                    await message.answer("Chat not found. It may have been deleted or expired.")
                     return
-                else:
-                    logger.debug(f"[DEEP_LINK] No regular chat found with ID: {numeric_id}")
-            except (ValueError, TypeError):
-                logger.debug(f"[DEEP_LINK] Session ID is not a valid number: {session_id}")
-            
-            # If we're here, try the AnonymousChatSession approach
-            chat_session = await get_by_session_id(session, session_id)
-            if not chat_session:
-                logger.error(f"[DEEP_LINK] Chat session not found for session_id: {session_id}")
-                await message.answer("Chat session not found. It may have been deleted or expired.")
                 
-                # Try to help debug the issue by listing recent sessions
-                recent_query = select(AnonymousChatSession).order_by(AnonymousChatSession.created_at.desc()).limit(5)
-                recent_result = await session.execute(recent_query)
-                recent_sessions = recent_result.scalars().all()
+                # Determine partner
+                partner_id = chat.recipient_id if user.id == chat.initiator_id else chat.initiator_id
+                
+                # Get partner info
+                partner = await user_repo.get(session, partner_id)
+                if not partner:
+                    logger.error(f"[DEEP_LINK] Partner with ID {partner_id} not found")
+                    await message.answer("Partner not found in database. They may have deleted their account.")
+                    return
                 
-                # Also check for regular chats
-                recent_chats_query = select(Chat).order_by(Chat.created_at.desc()).limit(5)
-                recent_chats_result = await session.execute(recent_chats_query)
-                recent_chats = recent_chats_result.scalars().all()
+                # Set up state for chat
+                await state.set_state(ChatState.in_chat)
+                await state.update_data({
+                    "chat_id": chat.id,
+                    "partner_id": partner_id
+                })
                 
-                logger.info(f"[DEEP_LINK] Recent anonymous chat sessions ({len(recent_sessions)} found):")
-                for sess in recent_sessions:
-                    logger.info(f"[DEEP_LINK] Anonymous Session: ID={sess.id}, session_id={sess.session_id}, status={sess.status}, created={sess.created_at}")
+                # Mark messages as read
+                await mark_messages_as_read(session, chat.id, user.id)
                 
-                logger.info(f"[DEEP_LINK] Recent regular chats ({len(recent_chats)} found):")
-                for chat in recent_chats:
-                    logger.info(f"[DEEP_LINK] Regular Chat: ID={chat.id}, initiator={chat.initiator_id}, recipient={chat.recipient_id}, status={chat.status}, created={chat.created_at}")
+                # Get partner's nickname
+                partner_name = await get_partner_nickname(session, partner_id)
                 
+                # Get recent messages
+                messages_limit = 5
+                recent_messages = await chat_message_repo.get_chat_messages(
+                    session, chat.id, limit=messages_limit
+                )
+                
+                # Format recent messages
+                message_history = ""
+                if recent_messages:
+                    message_history = "Recent messages:\n\n"
+                    for msg in reversed(recent_messages):  # Show in chronological order
+                        sender = "You" if msg.sender_id == user.id else partner_name
+                        message_history += f"{sender}: {msg.text_content}\n"
+                
+                # Send welcome message
+                await message.answer(
+                    f"Connected with {partner_name}!\n\n"
+                    f"{message_history}\n"
+                    "Your messages will be forwarded to your match.",
+                    reply_markup=get_in_chat_keyboard(partner_name)
+                )
+                logger.info(f"[DEEP_LINK] Successfully connected user {user_id} with partner {partner_id} in chat")
                 return
-            
-            logger.debug(f"[DEEP_LINK] Found anonymous chat session: ID={chat_session.id}, initiator={chat_session.initiator_id}, recipient={chat_session.recipient_id}, status={chat_session.status}")
-        except Exception as e:
-            logger.error(f"[DEEP_LINK] Database error when getting chat session: {e}")
-            await message.answer("Database error when retrieving chat session. Please try again.")
-            return
-
-        # Check if chat session is active
-        if chat_session.status != "active":
-            logger.warning(f"[DEEP_LINK] Chat session {chat_session.id} is not active (status: {chat_session.status})")
-            if chat_session.status == "ended":
-                await message.answer("This chat has ended. Please create a new match to start a new conversation.")
+                
+            except (ValueError, IndexError, Exception) as e:
+                logger.error(f"[DEEP_LINK] Error processing chat deep link: {e}")
+                await message.answer("Invalid chat link. Please use the link provided after finding a match.")
                 return
-            else:
-                # Try to activate the chat
-                try:
-                    logger.debug(f"[DEEP_LINK] Attempting to activate chat session {chat_session.id}")
-                    await update_status(session, chat_session.id, "active")
-                    logger.info(f"[DEEP_LINK] Activated chat session {chat_session.id}")
-                except Exception as e:
-                    logger.error(f"[DEEP_LINK] Failed to activate chat session: {e}")
-                    await message.answer("Failed to activate chat session. Please try again.")
+                
+        elif payload.startswith("match_"):
+            # Match link - create a new chat
+            try:
+                match_id = int(payload.split('_')[1])
+                logger.debug(f"[DEEP_LINK] Extracted match_id from payload: {match_id}")
+                
+                # Get match
+                match = await get_with_users(session, match_id)
+                if not match:
+                    logger.error(f"[DEEP_LINK] Match with ID {match_id} not found")
+                    await message.answer("Match not found. It may have been deleted.")
                     return
-
-        # Get match details
-        match_id = chat_session.match_id
-        logger.debug(f"[DEEP_LINK] Getting match with ID: {match_id}")
-        try:
-            match = await get_with_users(session, match_id)
-            if not match:
-                logger.error(f"[DEEP_LINK] Match not found for match_id: {match_id}")
-                await message.answer("Match not found. It may have been deleted.")
+                
+                # Determine partner
+                partner_id = match.user2_id if user.id == match.user1_id else match.user1_id
+                
+                # Get partner
+                partner = await user_repo.get(session, partner_id)
+                if not partner:
+                    logger.error(f"[DEEP_LINK] Partner with ID {partner_id} not found")
+                    await message.answer("Partner not found in database. They may have deleted their account.")
+                    return
+                
+                # Create or find a chat between these users
+                chat = await find_or_create_chat(session, user.id, partner_id)
+                if not chat:
+                    logger.error(f"[DEEP_LINK] Failed to create or find chat between users {user.id} and {partner_id}")
+                    await message.answer("Error creating chat. Please try again.")
+                    return
+                
+                # Set up state for chat
+                await state.set_state(ChatState.in_chat)
+                await state.update_data({
+                    "chat_id": chat.id,
+                    "partner_id": partner_id
+                })
+                
+                # Get partner's nickname
+                partner_name = await get_partner_nickname(session, partner_id)
+                
+                # Send welcome message
+                await message.answer(
+                    f"Connected with {partner_name}!\n\n"
+                    f"Match score: {match.score:.0%}\n"
+                    f"Common questions: {match.common_questions or 0}\n\n"
+                    "Your messages will be forwarded to your match.",
+                    reply_markup=get_in_chat_keyboard(partner_name)
+                )
+                logger.info(f"[DEEP_LINK] Successfully connected user {user_id} with partner {partner_id} in new chat")
                 return
-            
-            logger.debug(f"[DEEP_LINK] Found match: ID={match.id}, score={match.score}, common_questions={match.common_questions}")
-        except Exception as e:
-            logger.error(f"[DEEP_LINK] Database error when getting match: {e}")
-            await message.answer("Database error when retrieving match information. Please try again.")
-            return
-
-        # Determine partner
-        partner_id = chat_session.recipient_id if user.id == chat_session.initiator_id else chat_session.initiator_id
-        logger.debug(f"[DEEP_LINK] Partner ID determined: {partner_id}")
-        
-        try:
-            partner = await user_repo.get(session, partner_id)
-            if not partner:
-                logger.error(f"[DEEP_LINK] Partner with ID {partner_id} not found")
-                await message.answer("Partner not found in database. They may have deleted their account.")
+                
+            except (ValueError, IndexError, Exception) as e:
+                logger.error(f"[DEEP_LINK] Error processing match deep link: {e}")
+                await message.answer("Invalid match link. Please use the link provided after finding a match.")
                 return
-            
-            logger.debug(f"[DEEP_LINK] Found partner: ID={partner.id}, telegram_id={partner.telegram_id}")
-        except Exception as e:
-            logger.error(f"[DEEP_LINK] Database error when getting partner: {e}")
-            await message.answer("Database error when retrieving partner information. Please try again.")
+                
+        else:
+            logger.error(f"[DEEP_LINK] Invalid payload format: {payload}. Expected chat_[id] or match_[id]")
+            await message.answer("Invalid link format. Please use the link provided after finding a match.")
             return
 
-        # Check if blocked
-        try:
-            logger.debug(f"[DEEP_LINK] Checking if user is blocked by partner")
-            is_blocked = await blocked_user_repo.is_blocked(session, partner_id, user.id)
-            if is_blocked:
-                logger.warning(f"[DEEP_LINK] User {user_id} is blocked by partner {partner_id}")
-                await message.answer("This user has blocked you.")
-                return
-
-            # Check if user has blocked partner
-            logger.debug(f"[DEEP_LINK] Checking if user has blocked partner")
-            has_blocked = await blocked_user_repo.is_blocked(session, user.id, partner_id)
-            if has_blocked:
-                logger.warning(f"[DEEP_LINK] User {user_id} has blocked partner {partner_id}")
-                await message.answer("You have blocked this user. Unblock them first.")
-                return
-        except Exception as e:
-            logger.error(f"[DEEP_LINK] Error checking blocked status: {e}")
-            # Continue anyway since this is not critical
-
-        # Set up state for chat
-        try:
-            logger.debug(f"[DEEP_LINK] Setting up state for chat")
-            await state.set_state(ChatState.in_chat)
-            await state.update_data({
-                "chat_session_id": chat_session.id,
-                "partner_id": partner_id,
-                "session_id": chat_session.session_id,
-                "match_id": match_id
-            })
-            
-            # Get partner's display name
-            logger.debug(f"[DEEP_LINK] Getting partner's nickname")
-            partner_name = await get_partner_nickname(session, partner_id)
-            logger.debug(f"[DEEP_LINK] Partner nickname: {partner_name}")
-        except Exception as e:
-            logger.error(f"[DEEP_LINK] Error setting up chat state: {e}")
-            await message.answer("Error setting up chat state. Please try again.")
-            return
-        
-        try:
-            # Mark messages as read
-            logger.debug(f"[DEEP_LINK] Marking messages as read")
-            await mark_messages_as_read(session, chat_session.id, user.id)
-            
-            # Load recent messages
-            logger.debug(f"[DEEP_LINK] Loading recent messages")
-            recent_messages = await chat_message_repo.get_chat_messages(
-                session, chat_session.id, limit=5
-            )
-            
-            # Format recent messages
-            message_history = ""
-            if recent_messages:
-                message_history = "Recent messages:\n\n"
-                for msg in reversed(recent_messages):  # Show in chronological order
-                    sender = "You" if msg.sender_id == user.id else partner_name
-                    message_history += f"{sender}: {msg.text_content}\n"
-        except Exception as e:
-            logger.error(f"[DEEP_LINK] Error getting recent messages: {e}")
-            message_history = "Could not load recent messages."
-        
-        try:
-            logger.debug(f"[DEEP_LINK] Sending chat welcome message to user {user_id}")
-            await message.answer(
-                f"Connected with {partner_name}!\n\n"
-                f"Match score: {match.score:.0%}\n"
-                f"Common questions: {match.common_questions or 0}\n\n"
-                f"{message_history}\n"
-                "Your messages will be forwarded to your match.",
-                reply_markup=get_in_chat_keyboard(partner_name)
-            )
-            logger.info(f"[DEEP_LINK] Successfully connected user {user_id} with partner {partner_id} in chat")
-        except Exception as e:
-            logger.error(f"[DEEP_LINK] Error sending welcome message: {e}")
-            await message.answer(f"Connected with {partner_name}! However, there was an error loading the chat details.")
     except Exception as e:
         import traceback
         logger.exception(f"[DEEP_LINK] Error in handle_start_with_link: {e}")
@@ -382,7 +288,7 @@ async def handle_start_without_link(
     session: AsyncSession = None,
     bot: Bot = None
 ):
-    """Handle direct start command without deep link. Shows main menu."""
+    """Handle direct start command without deep link. Shows active chats as inline buttons."""
     if not session or not state:
         logger.error("Missing required dependencies for handle_start_without_link")
         await message.answer("An error occurred. Please try again later.")
@@ -393,19 +299,55 @@ async def handle_start_without_link(
         await message.answer("You need to register in the main bot first.")
         return
     
-    # Get unread messages summary
-    unread_summary = await get_unread_chat_summary(session, user.id)
-    total_unread = sum(chat["unread_count"] for chat in unread_summary)
+    # Get all active chats directly
+    all_chats = await get_active_chats_for_user(session, user.id)
+    logger.info(f"Found {len(all_chats)} active chats for user {user.id}")
     
-    # Show welcome message with unread count
-    if total_unread > 0:
+    if not all_chats:
         await message.answer(
-            f"Welcome back! You have {total_unread} unread message(s). "
-            "Showing main menu..."
+            "You don't have any active chats yet. Find a match in the main bot first!"
         )
+        return
     
-    # Show main menu
-    await show_main_menu(message, state, session)
+    # Format users for keyboard
+    users_data = []
+    
+    for chat in all_chats:
+        # Determine partner ID
+        partner_id = chat.recipient_id if chat.initiator_id == user.id else chat.initiator_id
+        partner = await user_repo.get(session, partner_id)
+        
+        if not partner:
+            continue
+        
+        # Get unread count
+        unread_count = await get_unread_message_count(session, chat.id, user.id)
+        
+        # Get partner nickname
+        partner_name = await get_partner_nickname(session, partner_id)
+        
+        # Create user data entry
+        users_data.append({
+            "id": partner.id,
+            "name": partner_name,
+            "unread_count": unread_count,
+            "chat_id": chat.id
+        })
+    
+    # Sort users - unread messages first, then alphabetically
+    users_data.sort(key=lambda x: (-(x['unread_count'] > 0), x['name']))
+    
+    # Show available chats directly
+    if users_data:
+        await message.answer(
+            "Select a chat to start messaging:",
+            reply_markup=get_chat_selection_keyboard(users_data)
+        )
+        await state.set_state(ChatState.selecting_chat)
+    else:
+        await message.answer(
+            "You don't have any active chats yet. Find a match in the main bot first!"
+        )
 
 
 # Select chat partner
@@ -416,56 +358,58 @@ async def show_chat_selection(message: Message, state: FSMContext, session: Asyn
     if not user:
         await message.answer("You need to register in the main bot first.")
         return
-        
+    
     # Get all active chats
-    active_chats = await get_active_chats_for_user(session, user.id)
+    all_chats = await get_active_chats_for_user(session, user.id)
+    logger.info(f"Found {len(all_chats)} active chats for user {user.id}")
     
-    if not active_chats:
+    if not all_chats:
         await message.answer(
             "You don't have any active chats yet. Find a match in the main bot first!",
             reply_markup=get_back_to_menu_keyboard()
         )
         return
-        
+    
     # Format users for keyboard
     users_data = []
-    for chat in active_chats:
+    
+    for chat in all_chats:
+        logger.info(f"Processing chat ID {chat.id} for user {user.id}")
+        
         # Determine partner ID
         partner_id = chat.recipient_id if chat.initiator_id == user.id else chat.initiator_id
         partner = await user_repo.get(session, partner_id)
         
         if not partner:
+            logger.info(f"Partner with ID {partner_id} not found, skipping")
             continue
-            
+        
         # Get unread count
         unread_count = await get_unread_message_count(session, chat.id, user.id)
         
         # Get partner nickname
-        partner_name = await get_partner_nickname(session, partner_id, chat.group_id if hasattr(chat, 'group_id') else None)
+        partner_name = await get_partner_nickname(session, partner_id)
         
         # Get latest message preview
         latest_message = ""
-        if hasattr(chat, 'is_group_chat') and chat.is_group_chat:
-            # For group chats, we don't have message history in database
-            latest_message = "Group chat"
-        else:
-            # For anonymous chats, get the latest message
-            recent_message = await chat_message_repo.get_latest_message(session, chat.id)
-            if recent_message:
-                # Format timestamp
-                timestamp = recent_message.created_at.strftime("%H:%M")
-                
-                # Format sender
-                sender_prefix = "You: " if recent_message.sender_id == user.id else ""
+        
+        # Get the latest message
+        recent_message = await chat_message_repo.get_latest_message(session, chat.id)
+        if recent_message:
+            # Format timestamp
+            timestamp = recent_message.created_at.strftime("%H:%M")
+            
+            # Format sender
+            sender_prefix = "You: " if recent_message.sender_id == user.id else ""
+            
+            message_text = recent_message.text_content or ""
+            # Truncate long messages
+            if len(message_text) > 30:
+                message_text = message_text[:27] + "..."
                 
-                message_text = recent_message.text_content
-                # Truncate long messages
-                if len(message_text) > 30:
-                    message_text = message_text[:27] + "..."
-                    
-                latest_message = f"{timestamp} {sender_prefix}{message_text}"
-            else:
-                latest_message = "No messages yet"
+            latest_message = f"{timestamp} {sender_prefix}{message_text}"
+        else:
+            latest_message = "No messages yet"
         
         # Create user data entry
         users_data.append({
@@ -473,13 +417,22 @@ async def show_chat_selection(message: Message, state: FSMContext, session: Asyn
             "name": partner_name,
             "unread_count": unread_count,
             "chat_id": chat.id,
-            "is_group_chat": hasattr(chat, 'is_group_chat') and chat.is_group_chat,
+            "is_group_chat": False,
             "latest_message": latest_message
         })
     
+    logger.info(f"Final user data count: {len(users_data)}")
+    
     # Sort users - unread messages first, then by latest activity
     users_data.sort(key=lambda x: (-(x['unread_count'] > 0), x['name']))
     
+    if not users_data:
+        await message.answer(
+            "You don't have any active chats yet. Find a match in the main bot first!",
+            reply_markup=get_back_to_menu_keyboard()
+        )
+        return
+    
     await message.answer(
         "Select a user to chat with:",
         reply_markup=get_chat_selection_keyboard(users_data)
@@ -499,11 +452,12 @@ async def on_chat_selected(callback: CallbackQuery, state: FSMContext, session:
         await callback.message.answer("You need to register in the main bot first.")
         return
     
-    # Parse the callback data which now includes chat_id and is_group_chat
+    # Parse the callback data 
     callback_parts = callback.data.split(":")
     partner_id = int(callback_parts[1])
     chat_id = int(callback_parts[2]) if len(callback_parts) > 2 else None
-    is_group_chat = callback_parts[3] == "true" if len(callback_parts) > 3 else False
+    
+    logger.info(f"Chat selected: partner_id={partner_id}, chat_id={chat_id}")
     
     partner = await user_repo.get(session, partner_id)
     
@@ -511,125 +465,118 @@ async def on_chat_selected(callback: CallbackQuery, state: FSMContext, session:
         await callback.message.answer("Partner not found.")
         return
     
-    # Set up different state data based on chat type
-    if is_group_chat:
-        # This is a regular group chat from the Chat model
+    # Find or use existing chat
+    if chat_id:
+        # Get existing chat
         chat = await get_chat_by_id(session, chat_id)
         if not chat:
+            logger.error(f"Chat with ID {chat_id} not found")
             await callback.message.answer("Chat not found.")
             return
-        
-        # Set up the state for group chat
-        await state.set_state(ChatState.in_chat)
-        await state.update_data({
-            "chat_id": chat.id,
-            "partner_id": partner_id,
-            "group_id": chat.group_id,
-            "is_group_chat": True
-        })
-        
-        # Get partner's display name
-        partner_name = await get_partner_nickname(session, partner_id, chat.group_id)
-        
-        await callback.message.edit_text(
-            f"Chat with {partner_name}\n\n",
-            reply_markup=None
-        )
-        
-        await callback.message.answer(
-            f"Now chatting with {partner_name}. Type your message to send.",
-            reply_markup=get_in_chat_keyboard(partner_name)
-        )
     else:
-        # This is an anonymous chat session
-        # Find or create chat session
-        if chat_id:
-            # Use existing chat session
-            chat_session = await session.get(AnonymousChatSession, chat_id)
-            if not chat_session:
-                await callback.message.answer("Chat session not found.")
-                return
-        else:
-            # Find the match between these users
-            match = await get_match_between_users(session, user.id, partner_id)
-            if not match:
-                await callback.message.answer("No match found with this user.")
-                return
-            
-            # Find active chat session by match
-            chat_session = await get_chat_session_by_match(session, match.id)
-            
-            if not chat_session:
-                # Create new chat session if none exists
-                chat_session = await create_chat_session(
-                    session,
-                    initiator_id=user.id,
-                    recipient_id=partner_id,
-                    match_id=match.id,
-                )
-                await update_status(session, chat_session.id, "active")
-        
-        # Mark all messages as read
-        await mark_messages_as_read(session, chat_session.id, user.id)
-        
-        # Set up the state for anonymous chat
-        await state.set_state(ChatState.in_chat)
-        await state.update_data({
-            "chat_session_id": chat_session.id,
-            "partner_id": partner_id,
-            "session_id": chat_session.session_id,
-            "match_id": chat_session.match_id,
-            "is_group_chat": False
-        })
-        
-        # Get partner's display name
-        partner_name = await get_partner_nickname(session, partner_id)
-        
-        # Get recent messages - load more than before
-        messages_limit = 20
-        recent_messages = await chat_message_repo.get_chat_messages(
-            session, chat_session.id, limit=messages_limit
-        )
-        
-        # Check if there are more messages
-        total_messages = await chat_message_repo.count_chat_messages(session, chat_session.id)
-        has_more_messages = total_messages > messages_limit
-        
+        # Find or create a chat between these users
+        chat = await find_or_create_chat(session, user.id, partner_id)
+        if not chat:
+            logger.error(f"Failed to create chat between users {user.id} and {partner_id}")
+            await callback.message.answer("Failed to create chat. Please try again.")
+            return
+    
+    logger.info(f"Using chat {chat.id} for users {user.id} and {partner_id}")
+    
+    # Mark messages as read if needed
+    marked_count = await mark_messages_as_read(session, chat.id, user.id)
+    logger.info(f"Marked {marked_count} messages as read for user {user.id} in chat {chat.id}")
+    
+    # Set up the state for chat
+    await state.set_state(ChatState.in_chat)
+    await state.update_data({
+        "chat_id": chat.id,
+        "partner_id": partner_id
+    })
+    
+    # Get partner's display name
+    partner_name = await get_partner_nickname(session, partner_id)
+    
+    # Edit the original message to remove selection buttons
+    await callback.message.edit_text(
+        f"Chat with {partner_name}",
+        reply_markup=None
+    )
+    
+    # Get recent messages
+    messages_limit = 50  # Increased limit for better history
+    recent_messages = await chat_message_repo.get_chat_messages(
+        session, chat.id, limit=messages_limit
+    )
+    
+    # Log message retrieval
+    logger.info(f"Retrieved {len(recent_messages)} recent messages for chat {chat.id}")
+    
+    # Check if there are more messages
+    total_messages = await chat_message_repo.count_chat_messages(session, chat.id)
+    has_more_messages = total_messages > messages_limit
+    
+    # Send the in-chat keyboard
+    keyboard_message = await callback.message.answer(
+        "👇 Your keyboard 👇",
+        reply_markup=get_in_chat_keyboard(partner_name)
+    )
+    
+    # Only display the history if there are messages
+    if recent_messages:
         # Format messages with timestamps
         message_history = ""
-        if recent_messages:
-            for msg in reversed(recent_messages):  # Show in chronological order
-                sender = "You" if msg.sender_id == user.id else partner_name
-                timestamp = msg.created_at.strftime("%H:%M")
-                message_history += f"[{timestamp}] {sender}: {msg.text_content}\n\n"
-        else:
-            message_history = "No messages yet. Start the conversation!"
-        
-        # Edit the original message
-        await callback.message.edit_text(
-            f"Chat with {partner_name}",
-            reply_markup=None
-        )
-        
-        # Send a new message with chat history
-        history_message = await callback.message.answer(
-            f"<b>Chat with {partner_name}</b>\n\n{message_history}",
-            reply_markup=get_chat_history_keyboard(
-                chat_session.id, 
-                0, 
-                has_more_messages
-            ),
-            parse_mode="HTML"
-        )
-        
-        # Store history message ID for later updates
-        await state.update_data({"history_message_id": history_message.message_id})
+        for msg in reversed(recent_messages):  # Show in chronological order
+            # Skip service messages, only show actual content
+            if not msg.text_content and not msg.file_id:
+                continue
+                
+            # Determine sender display name
+            sender = "You" if msg.sender_id == user.id else partner_name
+            timestamp = msg.created_at.strftime("%H:%M")
+            
+            # Format based on content type
+            if msg.content_type == "text":
+                content = msg.text_content or ""
+                # Escape any HTML characters in the message content for safety
+                content = content.replace("<", "&lt;").replace(">", "&gt;")
+                message_history += f"[{timestamp}] <b>{sender}</b>: {content}\n\n"
+            elif msg.content_type == "photo":
+                caption = msg.text_content or ""
+                caption = caption.replace("<", "&lt;").replace(">", "&gt;")
+                message_history += f"[{timestamp}] <b>{sender}</b>: 📷 Photo{': ' + caption if caption else ''}\n\n"
+            elif msg.content_type == "document":
+                caption = msg.text_content or ""
+                caption = caption.replace("<", "&lt;").replace(">", "&gt;")
+                message_history += f"[{timestamp}] <b>{sender}</b>: 📎 Document{': ' + caption if caption else ''}\n\n"
+            elif msg.content_type == "sticker":
+                message_history += f"[{timestamp}] <b>{sender}</b>: 🔖 Sticker\n\n"
+            elif msg.content_type == "voice":
+                message_history += f"[{timestamp}] <b>{sender}</b>: 🎤 Voice message\n\n"
+            else:
+                message_history += f"[{timestamp}] <b>{sender}</b>: Message\n\n"
         
-        # Send keyboard for chatting
-        await callback.message.answer(
-            f"Now chatting with {partner_name}. Type your message to send.",
-            reply_markup=get_in_chat_keyboard(partner_name)
-        )
+        # Only send message history if there's content to show
+        if message_history:
+            try:
+                history_message = await callback.message.answer(
+                    f"<b>Message History:</b>\n\n{message_history}",
+                    reply_markup=get_chat_history_keyboard(
+                        chat.id, 
+                        0, 
+                        has_more_messages
+                    ),
+                    parse_mode="HTML"
+                )
+                
+                # Store history message ID for later updates
+                await state.update_data({"history_message_id": history_message.message_id})
+                logger.info(f"Chat history message sent, ID: {history_message.message_id}")
+            except Exception as e:
+                logger.error(f"Error sending chat history: {e}")
+                await callback.message.answer(
+                    f"Error displaying chat history. Chat is still active, you can send messages."
+                )
 
 
 # Stop command
@@ -677,6 +624,47 @@ async def get_chat_by_id(session: AsyncSession, chat_id: int) -> Chat:
     result = await session.execute(query)
     return result.scalar_one_or_none()
 
+# Helper function to find or create chat
+async def find_or_create_chat(session: AsyncSession, user1_id: int, user2_id: int) -> Chat:
+    """
+    Find an existing chat between two users or create a new one.
+    
+    Args:
+        session: Database session
+        user1_id: ID of the first user
+        user2_id: ID of the second user
+        
+    Returns:
+        Chat object if found or created, None otherwise
+    """
+    # Check if chat already exists
+    query = select(Chat).where(
+        (
+            ((Chat.initiator_id == user1_id) & (Chat.recipient_id == user2_id)) |
+            ((Chat.initiator_id == user2_id) & (Chat.recipient_id == user1_id))
+        ) & 
+        (Chat.status == "active")
+    )
+    result = await session.execute(query)
+    existing_chat = result.scalar_one_or_none()
+    
+    if existing_chat:
+        return existing_chat
+    
+    # Create new chat
+    try:
+        new_chat = Chat(
+            initiator_id=user1_id,
+            recipient_id=user2_id,
+            status="active"
+        )
+        session.add(new_chat)
+        await session.commit()
+        await session.refresh(new_chat)
+        return new_chat
+    except Exception as e:
+        logger.error(f"Error creating chat: {e}")
+        return None
 
 # Handle chat opening from notifications
 @router.callback_query(F.data.startswith("open_chat:"))
@@ -694,7 +682,6 @@ async def on_open_chat_from_notification(callback: CallbackQuery, state: FSMCont
         parts = callback.data.split(":")
         partner_id = int(parts[1])
         chat_id = int(parts[2])
-        is_group_chat = parts[3] == "true"
     except (ValueError, IndexError):
         logger.error(f"Invalid callback data: {callback.data}")
         await callback.message.answer("Invalid callback data. Please try selecting a chat from the menu.")
@@ -706,84 +693,84 @@ async def on_open_chat_from_notification(callback: CallbackQuery, state: FSMCont
         await callback.message.answer("Partner not found.")
         return
     
-    # Set up chat state based on type
+    # Set up chat state
     await state.set_state(ChatState.in_chat)
     
-    if is_group_chat:
-        # Regular chat
-        chat = await get_chat_by_id(session, chat_id)
-        if not chat:
-            await callback.message.answer("Chat not found.")
-            return
-            
-        # Set state data
-        await state.update_data({
-            "chat_id": chat.id,
-            "partner_id": partner_id,
-            "group_id": chat.group_id,
-            "is_group_chat": True
-        })
-        
-        # Get partner name
-        partner_name = await get_partner_nickname(session, partner_id, chat.group_id)
-        
-        # Edit notification message
-        await callback.message.edit_text(
-            f"You are now chatting with {partner_name}. Your messages will be forwarded to them.",
-            reply_markup=None
-        )
+    # Get chat
+    chat = await get_chat_by_id(session, chat_id)
+    if not chat:
+        logger.error(f"Chat with ID {chat_id} not found when opening from notification.")
+        await callback.message.answer("Chat not found.")
+        return
         
-        # Send welcome message
-        await callback.message.answer(
-            f"Now chatting with {partner_name}. Type your message to send.",
-            reply_markup=get_in_chat_keyboard(partner_name)
-        )
+    # Mark messages as read
+    marked_count = await mark_messages_as_read(session, chat.id, user.id)
+    logger.info(f"Marked {marked_count} messages as read for user {user.id} in chat {chat.id} when opening from notification.")
+    
+    # Set state data
+    await state.update_data({
+        "chat_id": chat.id,
+        "partner_id": partner_id
+    })
+    
+    # Get partner name
+    partner_name = await get_partner_nickname(session, partner_id)
+    
+    # Get recent messages
+    messages_limit = 20
+    recent_messages = await chat_message_repo.get_chat_messages(
+        session, chat.id, limit=messages_limit
+    )
+    
+    # Log message retrieval
+    logger.info(f"Retrieved {len(recent_messages)} recent messages for chat {chat.id} when opening from notification.")
+    
+    # Check if there are more messages
+    total_messages = await chat_message_repo.count_chat_messages(session, chat.id)
+    has_more_messages = total_messages > messages_limit
+    
+    # Format messages with timestamps
+    message_history = ""
+    if recent_messages:
+        for msg in reversed(recent_messages):  # Show in chronological order
+            sender = "You" if msg.sender_id == user.id else partner_name
+            timestamp = msg.created_at.strftime("%H:%M")
+            content = msg.text_content or ""
+            # Escape any HTML characters in the message content for safety
+            content = content.replace("<", "&lt;").replace(">", "&gt;")
+            message_history += f"[{timestamp}] <b>{sender}</b>: {content}\n\n"
     else:
-        # Anonymous chat session
-        chat_session = await session.get(AnonymousChatSession, chat_id)
-        if not chat_session:
-            await callback.message.answer("Chat session not found.")
-            return
-            
-        # Mark messages as read
-        await mark_messages_as_read(session, chat_session.id, user.id)
-        
-        # Set state data
-        await state.update_data({
-            "chat_session_id": chat_session.id,
-            "partner_id": partner_id,
-            "session_id": chat_session.session_id,
-            "match_id": chat_session.match_id,
-            "is_group_chat": False
-        })
-        
-        # Get partner name
-        partner_name = await get_partner_nickname(session, partner_id)
-        
-        # Get recent messages
-        recent_messages = await chat_message_repo.get_chat_messages(
-            session, chat_session.id, limit=5
-        )
-        
-        # Format recent messages
-        message_history = ""
-        if recent_messages:
-            message_history = "Recent messages:\n\n"
-            for msg in reversed(recent_messages):  # Show in chronological order
-                sender = "You" if msg.sender_id == user.id else partner_name
-                message_history += f"{sender}: {msg.text_content}\n"
-        
-        # Edit notification message
-        await callback.message.edit_text(
-            f"You are now chatting with {partner_name}. Your messages will be forwarded to them.",
-            reply_markup=None
+        message_history = "No messages yet. Start the conversation!"
+    
+    # Edit notification message
+    await callback.message.edit_text(
+        f"You are now chatting with {partner_name}. Your messages will be forwarded to them.",
+        reply_markup=None
+    )
+    
+    # Send history message
+    try:
+        history_message = await callback.message.answer(
+            f"<b>Chat with {partner_name}</b>\n\n{message_history}",
+            reply_markup=get_chat_history_keyboard(
+                chat.id, 
+                0, 
+                has_more_messages
+            ),
+            parse_mode="HTML"
         )
         
-        # Send welcome message with chat history
-        await callback.message.answer(
-            f"Now chatting with {partner_name}.\n\n{message_history}\nType your message to send.",
-            reply_markup=get_in_chat_keyboard(partner_name)
-        )
+        # Store history message ID for later updates
+        await state.update_data({"history_message_id": history_message.message_id})
+        logger.info(f"Chat history message sent from notification, ID: {history_message.message_id}.")
+    except Exception as e:
+        logger.error(f"Error sending chat history from notification: {e}")
+    
+    # Send welcome message with chat keyboard
+    await callback.message.answer(
+        f"Now chatting with {partner_name}. Type your message to send.",
+        reply_markup=get_in_chat_keyboard(partner_name)
+    )
 
 # Handle load more messages callback
 @router.callback_query(F.data.startswith("load_more:"))
@@ -831,13 +818,43 @@ async def on_load_more_messages(callback: CallbackQuery, state: FSMContext, sess
     message_history = ""
     if older_messages:
         for msg in reversed(older_messages):  # Show in chronological order
+            # Skip service messages, only show actual content
+            if not msg.text_content and not msg.file_id:
+                continue
+                
             sender = "You" if msg.sender_id == callback.from_user.id else partner_name
-            timestamp = msg.created_at.strftime("%H:%M %d/%m")
-            message_history += f"[{timestamp}] {sender}: {msg.text_content}\n\n"
+            timestamp = msg.created_at.strftime("%d/%m %H:%M")
+            
+            # Format based on content type
+            if msg.content_type == "text":
+                content = msg.text_content or ""
+                # Escape any HTML characters in the message content for safety
+                content = content.replace("<", "&lt;").replace(">", "&gt;")
+                message_history += f"<b>{sender}</b>: {content}\n\n"
+            elif msg.content_type == "photo":
+                caption = msg.text_content or ""
+                caption = caption.replace("<", "&lt;").replace(">", "&gt;")
+                message_history += f"<b>{sender}</b>: 📷 Photo{': ' + caption if caption else ''}\n\n"
+            elif msg.content_type == "document":
+                caption = msg.text_content or ""
+                caption = caption.replace("<", "&lt;").replace(">", "&gt;")
+                message_history += f"<b>{sender}</b>: 📎 Document{': ' + caption if caption else ''}\n\n"
+            elif msg.content_type == "sticker":
+                message_history += f"<b>{sender}</b>: 🔖 Sticker\n\n"
+            elif msg.content_type == "voice":
+                message_history += f"<b>{sender}</b>: 🎤 Voice message\n\n"
+            else:
+                message_history += f"<b>{sender}</b>: Message\n\n"
     
     # Get the current message text content
     current_text = callback.message.text or ""
     
+    # Only show earlier messages if there are any
+    if not message_history:
+        await callback.message.edit_reply_markup(reply_markup=None)
+        await callback.message.answer("No more messages to load.")
+        return
+    
     # If we're showing older messages, create a header
     history_header = f"<b>Earlier Messages:</b>\n\n{message_history}\n"
     
@@ -863,4 +880,90 @@ async def on_load_more_messages(callback: CallbackQuery, state: FSMContext, sess
             history_header + separator + current_text,
             reply_markup=get_chat_history_keyboard(chat_id, offset, has_more_messages),
             parse_mode="HTML"
-        ) 
\ No newline at end of file
+        )
+
+# Handle "Switch chat" button
+@router.message(F.text == "👥 Switch chat")
+async def handle_switch_chat(message: Message, state: FSMContext, session: AsyncSession):
+    """Handle switch chat button and show available chats."""
+    user = await user_repo.get_by_telegram_id(session, message.from_user.id)
+    if not user:
+        await message.answer("You need to register in the main bot first.")
+        return
+    
+    # Get all active chats
+    all_chats = await get_active_chats_for_user(session, user.id)
+    logger.info(f"Found {len(all_chats)} active chats for user {user.id}")
+    
+    if not all_chats:
+        await message.answer(
+            "You don't have any other active chats."
+        )
+        return
+    
+    # Format users for keyboard
+    users_data = []
+    
+    for chat in all_chats:
+        # Determine partner ID
+        partner_id = chat.recipient_id if chat.initiator_id == user.id else chat.initiator_id
+        partner = await user_repo.get(session, partner_id)
+        
+        if not partner:
+            continue
+        
+        # Get unread count
+        unread_count = await get_unread_message_count(session, chat.id, user.id)
+        
+        # Get partner nickname
+        partner_name = await get_partner_nickname(session, partner_id)
+        
+        # Create user data entry
+        users_data.append({
+            "id": partner.id,
+            "name": partner_name,
+            "unread_count": unread_count,
+            "chat_id": chat.id
+        })
+    
+    # Sort users - unread messages first, then alphabetically
+    users_data.sort(key=lambda x: (-(x['unread_count'] > 0), x['name']))
+    
+    await message.answer(
+        "Select a user to chat with:",
+        reply_markup=get_chat_selection_keyboard(users_data)
+    )
+    
+    await state.set_state(ChatState.selecting_chat) 
+
+@router.message(F.text.startswith("🙌 What's next with"))
+async def handle_whats_next(message: Message, state: FSMContext, session: AsyncSession):
+    """Handle the user clicking the "What's next with [partner]" button."""
+    user_id = message.from_user.id
+    user = await user_repo.get_by_telegram_id(session, user_id)
+    
+    if not user:
+        await message.answer("You need to register in the main bot first.")
+        return
+    
+    data = await state.get_data()
+    partner_id = data.get("partner_id")
+    
+    if not partner_id:
+        await message.answer("You are not connected to anyone. Select a chat first.")
+        await state.clear()
+        return
+    
+    # Get partner
+    partner = await user_repo.get(session, partner_id)
+    if not partner:
+        await message.answer("Partner not found.")
+        return
+    
+    # Get partner nickname
+    partner_name = await get_partner_nickname(session, partner_id)
+    
+    await message.answer(
+        f"What would you like to do with your chat with {partner_name}?",
+        reply_markup=get_whats_next_keyboard(partner_id)
+    ) 
\ No newline at end of file
diff --git a/src/communicator_bot/handlers.py b/src/communicator_bot/handlers.py
index f171a8b..d3eaec2 100644
--- a/src/communicator_bot/handlers.py
+++ b/src/communicator_bot/handlers.py
@@ -1,289 +1,32 @@
-from aiogram import Bot, Dispatcher, F, Router, types
-from aiogram.filters import CommandStart, Command
-from aiogram.fsm.context import FSMContext
-from aiogram.types import Message
+"""
+Register all handlers for the communicator bot.
+"""
+from aiogram import Router, Dispatcher
 from loguru import logger
-from aiogram.fsm.storage.base import StorageKey
-from sqlalchemy.ext.asyncio import AsyncSession
-from datetime import datetime
 
-from .states import ChatState
-from .repositories import user_repo, get_by_session_id, update_status
+from .user_management import router as user_management_router
+from .chat_handlers import router as chat_router
+from .new_handlers import router as message_router
 
-# Simple in-memory storage for POC
-# In production, use a database
-user_nicknames = {} # user_id: nickname
-active_chats = {} # user_id: partner_id
+# Create a single router to combine all routers
+main_router = Router()
 
-router = Router()
 
-# TODO: Implement handlers:
-# 1. /start command handler
-# 2. Nickname processing handler
-# 3. Message relay handler
-# 4. /stop command handler
-
-@router.message(CommandStart(deep_link=True))
-async def handle_start_with_link(message: Message, state: FSMContext, bot: Bot):
-    """Handles the /start command with a deep link payload (e.g., from matching)."""
-    user_id = message.from_user.id
-    payload = message.text.split(' ')[1] # Get the payload after /start
-    logger.info(f"User {user_id} started communicator bot with payload: {payload}")
-
-    if user_id in active_chats:
-        await message.reply("You are already in a chat. Send /stop to leave.")
-        return
-
-    if not payload.startswith("match_"):
-        logger.warning(f"User {user_id} started with unknown payload format: {payload}")
-        await message.reply("Invalid link format. Please use the link provided after finding a match.")
-        await state.clear()
-        return
-
-    try:
-        _, user1_id_str, user2_id_str = payload.split('_')
-        user1_id = int(user1_id_str)
-        user2_id = int(user2_id_str)
-    except ValueError:
-        logger.error(f"Failed to parse user IDs from payload: {payload}")
-        await message.reply("Invalid link data. Please use the link provided after finding a match.")
-        await state.clear()
-        return
-
-    # Determine partner ID
-    if user_id == user1_id:
-        partner_id = user2_id
-    elif user_id == user2_id:
-        partner_id = user1_id
-    else:
-        logger.error(f"User {user_id} clicked link with payload {payload}, but is neither user1 nor user2.")
-        await message.reply("There seems to be an issue with this chat link. Please try matching again.")
-        await state.clear()
-        return
-
-    # --- Coordination Logic using FSM Data --- #
-    # We use FSM data associated with the *pair* (identified by the lower user ID)
-    # to coordinate the connection.
-    pair_key = f"pending_pair_{min(user1_id, user2_id)}_{max(user1_id, user2_id)}"
-    pair_data = await state.storage.get_data(bot=bot, key=StorageKey(bot.id, user_id, user_id)) # Use own chat/user ID for temp storage
-    pending_pair_info = pair_data.get(pair_key)
-
-    if pending_pair_info:
-        # The other user already clicked the link
-        other_user_activated = pending_pair_info.get("activated_user_id")
-        if other_user_activated == partner_id:
-            logger.info(f"User {user_id} is the second user to activate link for pair ({user1_id}, {user2_id}). Connecting.")
-            # Clean up pending data
-            await state.storage.set_data(bot=bot, key=StorageKey(bot.id, user_id, user_id), data={})
-
-            # Fetch nicknames (these should ideally be passed via payload or another mechanism)
-            # For POC, let's assign temporary names or prompt again if needed.
-            # Let's assign temporary ones for now.
-            user_nicknames[user_id] = f"User_{user_id % 1000}"
-            user_nicknames[partner_id] = f"User_{partner_id % 1000}"
-            your_nickname = user_nicknames[user_id]
-            partner_nickname = user_nicknames[partner_id]
-
-            # Connect users
-            active_chats[user_id] = partner_id
-            active_chats[partner_id] = user_id
-            await state.set_state(ChatState.in_chat)
-
-            # Set partner's state
-            partner_state = FSMContext(storage=state.storage, key=StorageKey(bot.id, partner_id, partner_id))
-            try:
-                await partner_state.set_state(ChatState.in_chat)
-                # Send connection messages
-                await bot.send_message(partner_id, f"You've been connected with '{your_nickname}'! Start chatting.")
-                await message.reply(f"You've been connected with '{partner_nickname}'! Start chatting.")
-                logger.info(f"Successfully connected pair ({user1_id}, {user2_id}).")
-            except Exception as e:
-                 logger.error(f"Failed to set partner state or notify partner {partner_id}: {e}. Disconnecting.")
-                 active_chats.pop(user_id, None)
-                 active_chats.pop(partner_id, None)
-                 user_nicknames.pop(user_id, None)
-                 user_nicknames.pop(partner_id, None)
-                 await state.clear()
-                 await message.reply("An error occurred connecting you. Please try again.")
-                 try: await partner_state.clear() # Attempt cleanup
-                 except: pass
-        else:
-             # Should not happen if logic is correct, but handle defensively
-             logger.error(f"State mismatch for pair key {pair_key}. Expected {partner_id}, found {other_user_activated}. Resetting.")
-             await state.storage.set_data(bot=bot, key=StorageKey(bot.id, user_id, user_id), data={})
-             await message.reply("There was a state mismatch. Please try the link again.")
-             await state.clear()
-
-    else:
-        # This is the first user to click the link for this pair
-        logger.info(f"User {user_id} is the first user to activate link for pair ({user1_id}, {user2_id}). Waiting.")
-        new_pair_data = {pair_key: {"activated_user_id": user_id}}
-        await state.storage.set_data(bot=bot, key=StorageKey(bot.id, user_id, user_id), data=new_pair_data)
-        await state.set_state(ChatState.waiting_for_link_activation)
-        await message.reply("Waiting for your match to join the chat...")
-
-
-@router.message(CommandStart(deep_link=False))
-async def handle_start_without_link(message: Message, state: FSMContext):
-    """Handles the /start command without deep link (direct start)."""
-    user_id = message.from_user.id
-    current_state = await state.get_state()
-    logger.info(f"User {user_id} started communicator bot directly (no link). State: {current_state}")
-
-    if user_id in active_chats:
-        await message.reply("You are already in a chat. Send /stop to leave.")
-        return
-    if current_state == ChatState.waiting_for_link_activation:
-        await message.reply("Waiting for your match to join the chat...")
-        return
-
-    # For now, direct start doesn't do anything in the matched chat context
-    # Could potentially add back the nickname/random pairing later if desired
-    await message.reply("Please use the invite link provided by the main bot after finding a match.")
-    await state.clear()
-
-
-@router.message(Command('stop'))
-async def handle_stop(message: Message, state: FSMContext, bot: Bot):
-    """Handles the /stop command to disconnect users or cancel waiting."""
-    user_id = message.from_user.id
-    current_state = await state.get_state()
-
-    # Check if user was waiting for link activation
-    if current_state == ChatState.waiting_for_link_activation:
-        logger.info(f"User {user_id} stopped while waiting for link activation.")
-        # Need to find the pair key to clean up
-        # This is complex without knowing the partner ID easily.
-        # Simplification: Just clear current user state. The pending data might become stale.
-        # A better approach needs robust pending match management (e.g., DB table, Redis with TTL).
-        await state.clear()
-        await message.reply("You have stopped waiting for the match.")
-        return
-
-    partner_id = active_chats.pop(user_id, None)
-    if partner_id:
-        active_chats.pop(partner_id, None) # Remove partner's entry too
-        partner_nickname = user_nicknames.pop(partner_id, "User")
-        your_nickname = user_nicknames.pop(user_id, "You")
-        logger.info(f"User {user_id} ({your_nickname}) disconnected from {partner_id} ({partner_nickname}).")
-        try:
-            # Try to clear partner state
-            partner_state = FSMContext(storage=state.storage, key=StorageKey(bot.id, partner_id, partner_id))
-            await partner_state.clear()
-            await bot.send_message(partner_id, "Your chat partner has disconnected. You can find a new match in the main bot.")
-        except Exception as e:
-            logger.warning(f"Could not notify or clear state for partner {partner_id} about disconnection: {e}")
-        await message.reply("You have been disconnected. You can find a new match in the main bot.")
-    else:
-        await message.reply("You are not currently in a chat.")
-
-    await state.clear()
-
-
-@router.message(ChatState.in_chat, F.text)
-async def relay_message(message: Message, state: FSMContext, bot: Bot, session: AsyncSession):
-    """Relays messages between paired users."""
-    user_id = message.from_user.id
-    data = await state.get_data()
-    chat_session_id = data.get("chat_session_id")
-    partner_id = data.get("partner_id")
-    
-    if not chat_session_id or not partner_id:
-        logger.warning(f"User {user_id} in state in_chat but no chat_session_id or partner_id found in state.")
-        await message.reply("You are not connected to anyone. Try finding a match in the main bot.")
-        await state.clear()
-        return
-    
-    # Get chat session
-    chat_session = await get_by_session_id(session, data.get("session_id"))
-    if not chat_session or chat_session.status != "active":
-        await message.reply("This chat is no longer active.")
-        await state.clear()
-        return
-    
-    # Get partner
-    partner = await user_repo.get(session, partner_id)
-    if not partner or not partner.telegram_id:
-        await message.reply("Cannot find your chat partner. They may have left.")
-        return
+def register_handlers(dp: Dispatcher) -> None:
+    """
+    Register all handlers for the communicator bot.
     
-    # Handle special commands
-    if message.text == "🔍 Reveal Identity":
-        # Handle identity revelation
-        user = await user_repo.get_by_telegram_id(session, user_id)
-        reveal_message = f"Your chat partner has revealed their identity:\n\n" \
-                        f"Name: {user.first_name} {user.last_name or ''}\n" \
-                        f"Username: @{user.username or 'N/A'}"
-        
-        await bot.send_message(chat_id=partner.telegram_id, text=reveal_message)
-        await message.answer("You've revealed your identity to your chat partner.")
-        return
-        
-    elif message.text == "❌ End Chat":
-        # Handle chat ending
-        await end_chat(message, state, session, bot)
-        return
+    Args:
+        dp: Dispatcher instance
+    """
+    logger.info("Registering communicator bot handlers")
     
-    # Regular message - forward it
-    try:
-        await bot.send_message(chat_id=partner.telegram_id, text=message.text)
-        
-        # Update last activity
-        chat_session.last_activity = datetime.utcnow()
-        await session.commit()
-        
-    except Exception as e:
-        logger.error(f"Error forwarding message: {e}")
-        await message.answer("Failed to send your message. The recipient may have blocked the bot.")
-        # End the chat for this user as well
-        await end_chat(message, state, session, bot)
-
-
-async def end_chat(message: Message, state: FSMContext, session: AsyncSession, bot: Bot):
-    """End the anonymous chat session."""
-    # Get state data
-    data = await state.get_data()
-    chat_session_id = data.get("chat_session_id")
-    partner_id = data.get("partner_id")
-    
-    if not chat_session_id:
-        await message.answer("No active chat found.")
-        await state.clear()
-        return
-    
-    # Get chat session
-    chat_session = await get_by_session_id(session, data.get("session_id"))
-    if not chat_session:
-        await message.answer("Chat session not found.")
-        await state.clear()
-        return
+    # Include all routers
+    main_router.include_router(chat_router)
+    main_router.include_router(message_router)
+    main_router.include_router(user_management_router)
     
-    # Mark chat as ended
-    chat_session = await update_status(session, chat_session.id, "ended", set_ended=True)
+    # Include main router in dispatcher
+    dp.include_router(main_router)
     
-    # Notify current user
-    keyboard = types.ReplyKeyboardRemove()
-    await message.answer(
-        "Chat has been ended. You can start a new chat from the main bot.",
-        reply_markup=keyboard
-    )
-    
-    # Notify partner if available
-    if partner_id:
-        partner = await user_repo.get(session, partner_id)
-        if partner and partner.telegram_id:
-            try:
-                await bot.send_message(
-                    chat_id=partner.telegram_id,
-                    text="Your chat partner has ended the conversation.",
-                    reply_markup=types.ReplyKeyboardRemove()
-                )
-            except Exception as e:
-                logger.error(f"Failed to notify partner about chat end: {e}")
-    
-    # Clear state
-    await state.clear()
-
-
-def register_handlers(dp: Dispatcher):
-    dp.include_router(router) 
\ No newline at end of file
+    logger.info("Registered all communicator bot handlers") 
\ No newline at end of file
diff --git a/src/communicator_bot/handlers.py.bak b/src/communicator_bot/handlers.py.bak
new file mode 100644
index 0000000..e565f9a
--- /dev/null
+++ b/src/communicator_bot/handlers.py.bak
@@ -0,0 +1,329 @@
+from aiogram import Bot, Dispatcher, F, Router, types
+from aiogram.filters import CommandStart, Command
+from aiogram.fsm.context import FSMContext
+from aiogram.types import Message, CallbackQuery
+from loguru import logger
+from aiogram.fsm.storage.base import StorageKey
+from sqlalchemy.ext.asyncio import AsyncSession
+from datetime import datetime
+
+from .states import ChatState
+from .repositories import user_repo, get_by_session_id, update_status
+from .keyboards import (
+    get_main_menu_keyboard,
+    get_chat_selection_keyboard,
+    get_user_management_keyboard,
+    get_select_user_to_manage_keyboard,
+    get_confirm_delete_keyboard,
+    get_confirm_block_keyboard,
+    get_in_chat_keyboard,
+    get_back_to_menu_keyboard
+)
+from .repositories import (
+    get_active_chats_for_user,
+    get_unread_message_count,
+    mark_messages_as_read,
+    get_chat_session_by_match,
+    get_partner_nickname,
+    end_chat_session
+)
+
+# Simple in-memory storage for POC
+# In production, use a database
+user_nicknames = {} # user_id: nickname
+active_chats = {} # user_id: partner_id
+
+router = Router()
+
+# TODO: Implement handlers:
+# 1. /start command handler
+# 2. Nickname processing handler
+# 3. Message relay handler
+# 4. /stop command handler
+
+@router.message(CommandStart(deep_link=True))
+async def handle_start_with_link(message: Message, state: FSMContext, bot: Bot):
+    """Handles the /start command with a deep link payload (e.g., from matching)."""
+    user_id = message.from_user.id
+    payload = message.text.split(' ')[1] # Get the payload after /start
+    logger.info(f"User {user_id} started communicator bot with payload: {payload}")
+
+    if user_id in active_chats:
+        await message.reply("You are already in a chat. Send /stop to leave.")
+        return
+
+    if not payload.startswith("match_"):
+        logger.warning(f"User {user_id} started with unknown payload format: {payload}")
+        await message.reply("Invalid link format. Please use the link provided after finding a match.")
+        await state.clear()
+        return
+
+    try:
+        _, user1_id_str, user2_id_str = payload.split('_')
+        user1_id = int(user1_id_str)
+        user2_id = int(user2_id_str)
+    except ValueError:
+        logger.error(f"Failed to parse user IDs from payload: {payload}")
+        await message.reply("Invalid link data. Please use the link provided after finding a match.")
+        await state.clear()
+        return
+
+    # Determine partner ID
+    if user_id == user1_id:
+        partner_id = user2_id
+    elif user_id == user2_id:
+        partner_id = user1_id
+    else:
+        logger.error(f"User {user_id} clicked link with payload {payload}, but is neither user1 nor user2.")
+        await message.reply("There seems to be an issue with this chat link. Please try matching again.")
+        await state.clear()
+        return
+
+    # --- Coordination Logic using FSM Data --- #
+    # We use FSM data associated with the *pair* (identified by the lower user ID)
+    # to coordinate the connection.
+    pair_key = f"pending_pair_{min(user1_id, user2_id)}_{max(user1_id, user2_id)}"
+    pair_data = await state.storage.get_data(bot=bot, key=StorageKey(bot.id, user_id, user_id)) # Use own chat/user ID for temp storage
+    pending_pair_info = pair_data.get(pair_key)
+
+    if pending_pair_info:
+        # The other user already clicked the link
+        other_user_activated = pending_pair_info.get("activated_user_id")
+        if other_user_activated == partner_id:
+            logger.info(f"User {user_id} is the second user to activate link for pair ({user1_id}, {user2_id}). Connecting.")
+            # Clean up pending data
+            await state.storage.set_data(bot=bot, key=StorageKey(bot.id, user_id, user_id), data={})
+
+            # Fetch nicknames (these should ideally be passed via payload or another mechanism)
+            # For POC, let's assign temporary names or prompt again if needed.
+            # Let's assign temporary ones for now.
+            user_nicknames[user_id] = f"User_{user_id % 1000}"
+            user_nicknames[partner_id] = f"User_{partner_id % 1000}"
+            your_nickname = user_nicknames[user_id]
+            partner_nickname = user_nicknames[partner_id]
+
+            # Connect users
+            active_chats[user_id] = partner_id
+            active_chats[partner_id] = user_id
+            await state.set_state(ChatState.in_chat)
+
+            # Set partner's state
+            partner_state = FSMContext(storage=state.storage, key=StorageKey(bot.id, partner_id, partner_id))
+            try:
+                await partner_state.set_state(ChatState.in_chat)
+                # Send connection messages
+                await bot.send_message(partner_id, f"You've been connected with '{your_nickname}'! Start chatting.")
+                await message.reply(f"You've been connected with '{partner_nickname}'! Start chatting.")
+                logger.info(f"Successfully connected pair ({user1_id}, {user2_id}).")
+            except Exception as e:
+                 logger.error(f"Failed to set partner state or notify partner {partner_id}: {e}. Disconnecting.")
+                 active_chats.pop(user_id, None)
+                 active_chats.pop(partner_id, None)
+                 user_nicknames.pop(user_id, None)
+                 user_nicknames.pop(partner_id, None)
+                 await state.clear()
+                 await message.reply("An error occurred connecting you. Please try again.")
+                 try: await partner_state.clear() # Attempt cleanup
+                 except: pass
+        else:
+             # Should not happen if logic is correct, but handle defensively
+             logger.error(f"State mismatch for pair key {pair_key}. Expected {partner_id}, found {other_user_activated}. Resetting.")
+             await state.storage.set_data(bot=bot, key=StorageKey(bot.id, user_id, user_id), data={})
+             await message.reply("There was a state mismatch. Please try the link again.")
+             await state.clear()
+
+    else:
+        # This is the first user to click the link for this pair
+        logger.info(f"User {user_id} is the first user to activate link for pair ({user1_id}, {user2_id}). Waiting.")
+        new_pair_data = {pair_key: {"activated_user_id": user_id}}
+        await state.storage.set_data(bot=bot, key=StorageKey(bot.id, user_id, user_id), data=new_pair_data)
+        await state.set_state(ChatState.waiting_for_link_activation)
+        await message.reply("Waiting for your match to join the chat...")
+
+
+@router.message(CommandStart(deep_link=False))
+async def handle_start_without_link(message: Message, state: FSMContext):
+    """Handles the /start command without deep link (direct start)."""
+    user_id = message.from_user.id
+    current_state = await state.get_state()
+    logger.info(f"User {user_id} started communicator bot directly (no link). State: {current_state}")
+
+    if user_id in active_chats:
+        await message.reply("You are already in a chat. Send /stop to leave.")
+        return
+    if current_state == ChatState.waiting_for_link_activation:
+        await message.reply("Waiting for your match to join the chat...")
+        return
+
+    # For now, direct start doesn't do anything in the matched chat context
+    # Could potentially add back the nickname/random pairing later if desired
+    await message.reply("Please use the invite link provided by the main bot after finding a match.")
+    await state.clear()
+
+
+@router.message(Command('stop'))
+async def handle_stop(message: Message, state: FSMContext, bot: Bot):
+    """Handles the /stop command to disconnect users or cancel waiting."""
+    user_id = message.from_user.id
+    current_state = await state.get_state()
+
+    # Check if user was waiting for link activation
+    if current_state == ChatState.waiting_for_link_activation:
+        logger.info(f"User {user_id} stopped while waiting for link activation.")
+        # Need to find the pair key to clean up
+        # This is complex without knowing the partner ID easily.
+        # Simplification: Just clear current user state. The pending data might become stale.
+        # A better approach needs robust pending match management (e.g., DB table, Redis with TTL).
+        await state.clear()
+        await message.reply("You have stopped waiting for the match.")
+        return
+
+    partner_id = active_chats.pop(user_id, None)
+    if partner_id:
+        active_chats.pop(partner_id, None) # Remove partner's entry too
+        partner_nickname = user_nicknames.pop(partner_id, "User")
+        your_nickname = user_nicknames.pop(user_id, "You")
+        logger.info(f"User {user_id} ({your_nickname}) disconnected from {partner_id} ({partner_nickname}).")
+        try:
+            # Try to clear partner state
+            partner_state = FSMContext(storage=state.storage, key=StorageKey(bot.id, partner_id, partner_id))
+            await partner_state.clear()
+            await bot.send_message(partner_id, "Your chat partner has disconnected. You can find a new match in the main bot.")
+        except Exception as e:
+            logger.warning(f"Could not notify or clear state for partner {partner_id} about disconnection: {e}")
+        await message.reply("You have been disconnected. You can find a new match in the main bot.")
+    else:
+        await message.reply("You are not currently in a chat.")
+
+    await state.clear()
+
+
+@router.message(ChatState.in_chat, F.text)
+async def relay_message(message: Message, state: FSMContext, bot: Bot, session: AsyncSession):
+    """Relays messages between paired users."""
+    user_id = message.from_user.id
+    data = await state.get_data()
+    chat_session_id = data.get("chat_session_id")
+    partner_id = data.get("partner_id")
+    
+    if not chat_session_id or not partner_id:
+        logger.warning(f"User {user_id} in state in_chat but no chat_session_id or partner_id found in state.")
+        await message.reply("You are not connected to anyone. Try finding a match in the main bot.")
+        await state.clear()
+        return
+    
+    # Get chat session
+    chat_session = await get_by_session_id(session, data.get("session_id"))
+    if not chat_session or chat_session.status != "active":
+        await message.reply("This chat is no longer active.")
+        await state.clear()
+        return
+    
+    # Get partner
+    partner = await user_repo.get(session, partner_id)
+    if not partner or not partner.telegram_id:
+        await message.reply("Cannot find your chat partner. They may have left.")
+        return
+    
+    # Handle special commands
+    if message.text == "🔍 Reveal Identity":
+        # Handle identity revelation
+        user = await user_repo.get_by_telegram_id(session, user_id)
+        reveal_message = f"Your chat partner has revealed their identity:\n\n" \
+                        f"Name: {user.first_name} {user.last_name or ''}\n" \
+                        f"Username: @{user.username or 'N/A'}"
+        
+        await bot.send_message(chat_id=partner.telegram_id, text=reveal_message)
+        await message.answer("You've revealed your identity to your chat partner.")
+        return
+        
+    elif message.text == "❌ End Chat":
+        # Handle chat ending
+        await end_chat(message, state, session, bot)
+        return
+    
+    # Regular message - forward it
+    try:
+        await bot.send_message(chat_id=partner.telegram_id, text=message.text)
+        
+        # Update last activity
+        chat_session.last_activity = datetime.utcnow()
+        await session.commit()
+        
+    except Exception as e:
+        logger.error(f"Error forwarding message: {e}")
+        await message.answer("Failed to send your message. The recipient may have blocked the bot.")
+        # End the chat for this user as well
+        await end_chat(message, state, session, bot)
+
+
+async def end_chat(message: Message, state: FSMContext, session: AsyncSession, bot: Bot):
+    """End the anonymous chat session."""
+    # Get state data
+    data = await state.get_data()
+    chat_session_id = data.get("chat_session_id")
+    partner_id = data.get("partner_id")
+    
+    if not chat_session_id:
+        await message.answer("No active chat found.")
+        await state.clear()
+        return
+    
+    # Get chat session
+    chat_session = await get_by_session_id(session, data.get("session_id"))
+    if not chat_session:
+        await message.answer("Chat session not found.")
+        await state.clear()
+        return
+    
+    # Mark chat as ended
+    chat_session = await update_status(session, chat_session.id, "ended", set_ended=True)
+    
+    # Notify current user
+    keyboard = types.ReplyKeyboardRemove()
+    await message.answer(
+        "Chat has been ended. You can start a new chat from the main bot.",
+        reply_markup=keyboard
+    )
+    
+    # Notify partner if available
+    if partner_id:
+        partner = await user_repo.get(session, partner_id)
+        if partner and partner.telegram_id:
+            try:
+                await bot.send_message(
+                    chat_id=partner.telegram_id,
+                    text="Your chat partner has ended the conversation.",
+                    reply_markup=types.ReplyKeyboardRemove()
+                )
+            except Exception as e:
+                logger.error(f"Failed to notify partner about chat end: {e}")
+    
+    # Clear state
+    await state.clear()
+
+
+@router.message(Command("menu"))
+@router.message(F.text == "🔙 Back to menu")
+async def show_main_menu(message: Message, state: FSMContext, session: AsyncSession):
+    """Show the main menu with options to select chat and manage users."""
+    await state.clear()  # Clear any active state
+    
+    # Get user
+    user = await user_repo.get_by_telegram_id(session, message.from_user.id)
+    if not user:
+        await message.answer("You need to register in the main bot first.")
+        return
+        
+    # Get all active chats
+    active_chats = await get_active_chats_for_user(session, user.id)
+    active_chat_count = len(active_chats)
+    
+    await message.answer(
+        f"Welcome to the chat menu! You have {active_chat_count} active chats.",
+        reply_markup=get_main_menu_keyboard()
+    )
+
+
+def register_handlers(dp: Dispatcher):
+    dp.include_router(router) 
\ No newline at end of file
diff --git a/src/communicator_bot/keyboards.py b/src/communicator_bot/keyboards.py
index 32141c0..98c8edc 100644
--- a/src/communicator_bot/keyboards.py
+++ b/src/communicator_bot/keyboards.py
@@ -34,14 +34,14 @@ def get_in_chat_keyboard(partner_name: str) -> types.ReplyKeyboardMarkup:
     """Creates a keyboard for when a user is in a chat."""
     builder = ReplyKeyboardBuilder()
     
-    # First row - current chat partner
+    # First row - What's Next button with partner name
     builder.row(
-        types.KeyboardButton(text=f"💬 Chatting with: {partner_name}")
+        types.KeyboardButton(text=f"🙌 What's next with {partner_name}?")
     )
     
-    # Second row - back to menu
+    # Second row - Switch chat button
     builder.row(
-        types.KeyboardButton(text="🔙 Back to menu")
+        types.KeyboardButton(text="👥 Switch chat")
     )
     
     return builder.as_markup(resize_keyboard=True, one_time_keyboard=False)
@@ -56,7 +56,7 @@ def get_chat_selection_keyboard(
     Creates a keyboard with users to select for chatting.
     
     Args:
-        users: List of user dicts with fields: id, name, unread_count, chat_id, is_group_chat, latest_message
+        users: List of user dicts with fields: id, name, unread_count, chat_id, latest_message
         page: Current page number (0-based)
         page_size: Number of users per page
         
@@ -75,26 +75,14 @@ def get_chat_selection_keyboard(
         user = users[i]
         unread_badge = f" 🔴({user['unread_count']})" if user.get('unread_count', 0) > 0 else ""
         
-        # Include chat_id and is_group_chat in callback data
+        # Include chat_id in callback data
         chat_id = user.get('chat_id', 0)
-        is_group_chat = "true" if user.get('is_group_chat', False) else "false"
         
         # Create button for user
-        builder.button(
+        builder.row(types.InlineKeyboardButton(
             text=f"{user['name']}{unread_badge}",
-            callback_data=f"chat:{user['id']}:{chat_id}:{is_group_chat}"
-        )
-        
-        # Add preview of latest message if available
-        if user.get('latest_message'):
-            preview = user['latest_message']
-            if len(preview) > 40:
-                preview = preview[:37] + "..."
-            
-            builder.button(
-                text=f"┗ {preview}",
-                callback_data=f"chat:{user['id']}:{chat_id}:{is_group_chat}"
-            )
+            callback_data=f"chat:{user['id']}:{chat_id}"
+        ))
     
     # Add pagination if needed
     pagination_row = []
@@ -121,12 +109,6 @@ def get_chat_selection_keyboard(
     if pagination_row:
         builder.row(*pagination_row)
     
-    # Add back button
-    builder.row(types.InlineKeyboardButton(
-        text="🔙 Back",
-        callback_data="back_to_menu"
-    ))
-    
     return builder.as_markup()
 
 
@@ -284,4 +266,32 @@ def get_chat_history_keyboard(
             callback_data=f"load_more:{chat_id}:{current_offset+20}"
         )
     
+    return builder.as_markup()
+
+
+def get_whats_next_keyboard(user_id: int) -> types.InlineKeyboardMarkup:
+    """Creates a keyboard with options for what to do next in a chat."""
+    builder = InlineKeyboardBuilder()
+    
+    # Options for what to do next
+    builder.row(types.InlineKeyboardButton(
+        text="💬 Keep Chatting",
+        callback_data=f"next_keep_chatting:{user_id}"
+    ))
+    
+    builder.row(types.InlineKeyboardButton(
+        text="👤 Share my Telegram account",
+        callback_data=f"next_connect_directly:{user_id}"
+    ))
+    
+    builder.row(types.InlineKeyboardButton(
+        text="🗑️ Delete Chat",
+        callback_data=f"delete_match:{user_id}"
+    ))
+    
+    builder.row(types.InlineKeyboardButton(
+        text="⛔ Block User",
+        callback_data=f"block_user:{user_id}"
+    ))
+    
     return builder.as_markup() 
\ No newline at end of file
diff --git a/src/communicator_bot/main.py b/src/communicator_bot/main.py
index dee87aa..f8f7557 100644
--- a/src/communicator_bot/main.py
+++ b/src/communicator_bot/main.py
@@ -7,10 +7,24 @@ import asyncio
 import os
 import signal
 import sys
+import aiohttp
+import ssl
 from dotenv import load_dotenv
+from aiogram.dispatcher.middlewares.base import BaseMiddleware
+from typing import Any, Awaitable, Callable, Dict
+from datetime import datetime
 
 from src.communicator_bot.handlers import register_handlers
 from src.core.config import get_settings
+from src.communicator_bot.middlewares import DatabaseMiddleware, LoggingMiddleware, BotMiddleware
+
+# Set up logging to a specific file for debugging
+current_time = datetime.now().strftime("%Y%m%d_%H%M%S")
+log_file = f"logs/communicator_debug_{current_time}.log"
+logger.remove()  # Remove default handlers
+logger.add(log_file, rotation="20 MB", level="DEBUG", backtrace=True, diagnose=True)
+logger.add(sys.stderr, level="INFO")
+logger.info(f"Communicator bot logs will be written to {log_file}")
 
 # Load env variables directly from .env file
 load_dotenv()
@@ -36,6 +50,56 @@ bot = None
 dp = None
 should_exit = False
 
+async def reset_webhook():
+    """Reset the Telegram webhook to ensure no conflicts."""
+    if not COMMUNICATOR_BOT_TOKEN:
+        logger.error("Cannot reset webhook: No token available")
+        return False
+        
+    try:
+        logger.info("Resetting Telegram webhook...")
+        # Create a default SSL context that doesn't verify
+        ssl_context = ssl.create_default_context()
+        ssl_context.check_hostname = False
+        ssl_context.verify_mode = ssl.CERT_NONE
+        
+        # Create a session with relaxed SSL configuration
+        connector = aiohttp.TCPConnector(ssl=ssl_context)
+        async with aiohttp.ClientSession(connector=connector) as session:
+            # First, check current webhook status
+            async with session.get(
+                f"https://api.telegram.org/bot{COMMUNICATOR_BOT_TOKEN}/getWebhookInfo"
+            ) as response:
+                webhook_info = await response.json()
+                logger.info(f"Current webhook status: {webhook_info}")
+            
+            # Force delete the webhook with drop_pending_updates
+            async with session.get(
+                f"https://api.telegram.org/bot{COMMUNICATOR_BOT_TOKEN}/deleteWebhook?drop_pending_updates=true"
+            ) as response:
+                result = await response.json()
+                if result.get("ok"):
+                    logger.info("Webhook deleted successfully")
+                else:
+                    logger.error(f"Failed to delete webhook: {result}")
+                    return False
+                    
+            # Verify webhook was deleted
+            await asyncio.sleep(1)  # Give Telegram a moment to process
+            async with session.get(
+                f"https://api.telegram.org/bot{COMMUNICATOR_BOT_TOKEN}/getWebhookInfo"
+            ) as response:
+                webhook_info = await response.json()
+                if webhook_info.get("ok") and not webhook_info.get("result", {}).get("url"):
+                    logger.info("Verified webhook is now empty")
+                    return True
+                else:
+                    logger.warning(f"Webhook might still be active: {webhook_info}")
+                    return False
+    except Exception as e:
+        logger.error(f"Error resetting webhook: {e}")
+        return False
+
 async def shutdown(signal_name=None):
     """Shutdown the bot gracefully."""
     global bot
@@ -62,6 +126,39 @@ async def start_communicator_bot() -> None:
         logger.error("Communicator Bot Token not found!")
         return
 
+    # Reset webhook before starting
+    if not await reset_webhook():
+        logger.warning("Could not reset webhook completely, will try one more time...")
+        # Wait a bit and try one more time
+        await asyncio.sleep(5)
+        if not await reset_webhook():
+            logger.error("Failed to reset webhook after multiple attempts, this may cause conflicts!")
+
+    # Kill any other running instances by name
+    try:
+        import subprocess
+        # This will only work on Unix systems, but it's a helpful safety check
+        logger.info("Checking for other communicator bot processes...")
+        result = subprocess.run(
+            "ps aux | grep 'src.communicator_bot.main' | grep -v grep | awk '{print $2}'", 
+            shell=True, 
+            capture_output=True, 
+            text=True
+        )
+        pids = result.stdout.strip().split('\n')
+        current_pid = os.getpid()
+        
+        for pid in pids:
+            if pid and pid.isdigit() and int(pid) != current_pid:
+                logger.warning(f"Found another communicator bot process with PID {pid}, attempting to terminate it")
+                try:
+                    os.kill(int(pid), signal.SIGTERM)
+                    logger.info(f"Sent SIGTERM to process {pid}")
+                except Exception as e:
+                    logger.error(f"Failed to terminate process {pid}: {e}")
+    except Exception as e:
+        logger.error(f"Error checking for other processes: {e}")
+
     try:
         logger.info("Creating bot instance with token...")
         bot = Bot(
@@ -79,25 +176,52 @@ async def start_communicator_bot() -> None:
 
         storage = MemoryStorage()
         dp = Dispatcher(storage=storage)
+        
+        # Register middlewares
+        dp.update.middleware(BotMiddleware(bot))
+        dp.update.middleware(DatabaseMiddleware())
+        dp.update.middleware(LoggingMiddleware())
 
         register_handlers(dp)
 
         logger.info("Starting communicator bot...")
         
-        # Start polling with proper error handling
-        while not should_exit:
+        # Give Telegram servers a moment to fully clear any previous connections
+        logger.info("Waiting 5 seconds before starting polling to ensure clean state...")
+        await asyncio.sleep(5)
+        
+        # Start polling with proper error handling and exponential backoff
+        retry_count = 0
+        max_retries = 10
+        base_delay = 2
+        
+        while not should_exit and retry_count < max_retries:
             try:
-                await dp.start_polling(bot, allowed_updates=["message", "callback_query"])
+                logger.info(f"Starting polling (attempt {retry_count+1}/{max_retries})...")
+                await dp.start_polling(bot, allowed_updates=["message", "callback_query", "my_chat_member"])
+                # If we get here, polling ended normally (unlikely)
+                logger.info("Polling ended normally")
+                break
             except Exception as e:
                 if "Conflict:" in str(e):
+                    retry_count += 1
+                    delay = min(300, base_delay * (2 ** retry_count))  # Exponential backoff with 5 min max
                     logger.warning(f"Telegram conflict error: {e}")
-                    logger.info("Waiting 10 seconds before reconnecting...")
-                    await asyncio.sleep(10)
+                    logger.info(f"Waiting {delay} seconds before attempt {retry_count+1}/{max_retries}...")
+                    
+                    # Try to reset webhook again
+                    await reset_webhook()
+                    await asyncio.sleep(delay)
                 else:
                     logger.exception(f"Error in bot polling: {e}")
                     if not should_exit:
-                        logger.info("Waiting 5 seconds before reconnecting...")
-                        await asyncio.sleep(5)
+                        retry_count += 1
+                        delay = min(60, base_delay * (2 ** retry_count))  # Exponential backoff with 1 min max
+                        logger.info(f"Waiting {delay} seconds before attempt {retry_count+1}/{max_retries}...")
+                        await asyncio.sleep(delay)
+            
+        if retry_count >= max_retries:
+            logger.error(f"Failed to start polling after {max_retries} attempts, giving up")
     except Exception as e:
         logger.exception(f"Error starting communicator bot: {e}")
     finally:
@@ -112,9 +236,6 @@ def setup_signal_handlers():
         )
 
 if __name__ == '__main__':
-    # Basic logger setup
-    logger.add("communicator_bot.log", rotation="1 week")
-    
     # Setup signal handlers
     setup_signal_handlers()
     
diff --git a/src/communicator_bot/navigation.py b/src/communicator_bot/navigation.py
new file mode 100644
index 0000000..5b08133
--- /dev/null
+++ b/src/communicator_bot/navigation.py
@@ -0,0 +1,69 @@
+"""
+Navigation handlers for the communicator bot.
+"""
+from aiogram import F, Router
+from aiogram.fsm.context import FSMContext
+from aiogram.types import CallbackQuery
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from src.db.repositories.user import user_repo
+
+from .keyboards import get_chat_selection_keyboard
+from .repositories import (
+    get_active_chats_for_user,
+    get_unread_message_count,
+    get_partner_nickname
+)
+from .chat_handlers import show_main_menu
+
+router = Router()
+
+# Chat page navigation
+@router.callback_query(F.data.startswith("page:"))
+async def on_page_change(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
+    """Handle pagination for chat selection."""
+    await callback.answer()
+    
+    page = int(callback.data.split(":")[1])
+    
+    user = await user_repo.get_by_telegram_id(session, callback.from_user.id)
+    if not user:
+        await callback.message.answer("You need to register in the main bot first.")
+        return
+        
+    # Get all active chats
+    active_chats = await get_active_chats_for_user(session, user.id)
+    
+    # Format users for keyboard
+    users_data = []
+    for chat in active_chats:
+        # Determine partner ID
+        partner_id = chat.recipient_id if chat.initiator_id == user.id else chat.initiator_id
+        partner = await user_repo.get(session, partner_id)
+        
+        if not partner:
+            continue
+            
+        # Get unread count
+        unread_count = await get_unread_message_count(session, chat.id, user.id)
+        
+        # Get partner nickname
+        partner_name = await get_partner_nickname(session, partner_id)
+        
+        users_data.append({
+            "id": partner.id,
+            "name": partner_name,
+            "unread_count": unread_count
+        })
+    
+    await callback.message.edit_text(
+        "Select a user to chat with:",
+        reply_markup=get_chat_selection_keyboard(users_data, page=page)
+    )
+
+
+# Handle noop callback (used for page indicators)
+@router.callback_query(F.data == "noop")
+async def on_noop(callback: CallbackQuery):
+    """Handle noop callback without changing anything."""
+    await callback.answer() 
\ No newline at end of file
diff --git a/src/communicator_bot/new_message_handlers.py b/src/communicator_bot/new_message_handlers.py
new file mode 100644
index 0000000..50ce5ae
--- /dev/null
+++ b/src/communicator_bot/new_message_handlers.py
@@ -0,0 +1,347 @@
+"""
+Message handling functionality for the communicator bot.
+"""
+from aiogram import F, Router, types, Bot
+from aiogram.fsm.context import FSMContext
+from aiogram.fsm.storage.base import StorageKey, BaseStorage
+from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
+from loguru import logger
+from sqlalchemy.ext.asyncio import AsyncSession
+from sqlalchemy import select
+from datetime import datetime
+
+from src.db.models import AnonymousChatSession, Chat
+from src.db.repositories.user import user_repo
+from src.db.repositories.chat_session_repo import get_by_session_id
+from src.db.repositories.chat_message_repo import chat_message_repo
+from src.communicator_bot.chat_handlers import get_chat_by_id
+
+from .states import ChatState
+from .keyboards import get_in_chat_keyboard
+from .repositories import get_partner_nickname
+
+
+async def check_recipient_state(
+    bot: Bot, 
+    storage: BaseStorage,
+    recipient_telegram_id: int,
+    sender_name: str,
+    chat_id: int,
+    partner_id: int,
+    is_group_chat: bool = False,
+    session_id: str = None,
+    group_id: int = None,
+    match_id: int = None
+) -> bool:
+    """
+    Check if recipient is in active chat with sender and notify if not.
+    
+    Args:
+        bot: Bot instance
+        storage: FSM storage
+        recipient_telegram_id: Telegram ID of the recipient
+        sender_name: Name of the sender to show in notification
+        chat_id: ID of the chat
+        partner_id: ID of the partner (sender)
+        is_group_chat: Whether this is a group chat
+        session_id: Session ID (for anonymous chats)
+        group_id: Group ID (for group chats)
+        match_id: Match ID (for anonymous chats)
+        
+    Returns:
+        True if notification was sent, False otherwise
+    """
+    try:
+        # Create a key for the recipient's state
+        key = StorageKey(bot_id=bot.id, user_id=recipient_telegram_id, chat_id=recipient_telegram_id)
+        
+        # Get the recipient's state
+        state = await storage.get_state(key=key)
+        
+        # If they have no state or aren't in chat, send notification
+        if state != ChatState.in_chat.state:
+            # They're not in chat state, send notification
+            logger.info(f"Sending notification to {recipient_telegram_id} about new message from {sender_name}")
+            
+            # Create deep link for direct chat access
+            open_chat_data = {
+                "chat_id": chat_id,
+                "partner_id": partner_id,
+                "is_group_chat": is_group_chat
+            }
+            
+            # Add type-specific data
+            if is_group_chat:
+                open_chat_data["group_id"] = group_id
+            else:
+                open_chat_data["session_id"] = session_id
+                open_chat_data["match_id"] = match_id
+            
+            # Create inline keyboard with button to open chat
+            keyboard = InlineKeyboardMarkup(
+                inline_keyboard=[
+                    [
+                        InlineKeyboardButton(
+                            text="📨 Open Chat",
+                            callback_data=f"open_chat:{partner_id}:{chat_id}:{'true' if is_group_chat else 'false'}"
+                        )
+                    ]
+                ]
+            )
+            
+            # Send notification
+            await bot.send_message(
+                chat_id=recipient_telegram_id,
+                text=f"📬 New message from {sender_name}!\n\nClick below to view and respond:",
+                reply_markup=keyboard
+            )
+            return True
+        else:
+            # They're in a chat state, check if it's with this sender
+            data = await storage.get_data(key=key)
+            current_partner_id = data.get("partner_id")
+            
+            if current_partner_id != partner_id:
+                # They're chatting with someone else, send notification
+                logger.info(f"User {recipient_telegram_id} is chatting with someone else, sending notification")
+                
+                # Create inline keyboard with button to switch chat
+                keyboard = InlineKeyboardMarkup(
+                    inline_keyboard=[
+                        [
+                            InlineKeyboardButton(
+                                text="📨 Switch to this Chat",
+                                callback_data=f"open_chat:{partner_id}:{chat_id}:{'true' if is_group_chat else 'false'}"
+                            )
+                        ]
+                    ]
+                )
+                
+                # Send notification
+                await bot.send_message(
+                    chat_id=recipient_telegram_id,
+                    text=f"📬 New message from {sender_name} while you're chatting with someone else!\n\nClick below to switch to this conversation:",
+                    reply_markup=keyboard
+                )
+                return True
+                
+            # They're already chatting with this sender, no need for notification
+            return False
+            
+    except Exception as e:
+        logger.error(f"Error checking recipient state: {e}")
+        return False
+
+
+router = Router()
+
+# Handle messages in chat
+@router.message(ChatState.in_chat, F.text)
+async def relay_message(message: Message, state: FSMContext, bot: Bot, session: AsyncSession):
+    """Relay messages between paired users."""
+    user_id = message.from_user.id
+    user = await user_repo.get_by_telegram_id(session, user_id)
+    
+    if not user:
+        await message.answer("You need to register in the main bot first.")
+        return
+    
+    data = await state.get_data()
+    
+    # Check if this is a group chat (Chat model) or anonymous chat (AnonymousChatSession model)
+    is_group_chat = data.get("is_group_chat", False)
+    partner_id = data.get("partner_id")
+    
+    if not partner_id:
+        await message.answer("You are not connected to anyone. Select a chat first.")
+        await state.clear()
+        return
+    
+    if is_group_chat:
+        chat_id = data.get("chat_id")
+        group_id = data.get("group_id")
+        # Get chat from Chat model
+        chat = await get_chat_by_id(session, chat_id)
+        
+        if not chat or chat.status != "active":
+            await message.answer("This chat is no longer active.")
+            await state.clear()
+            return
+            
+        # No need to save message for group chat, just forward it
+        partner = await user_repo.get(session, partner_id)
+        if not partner or not partner.telegram_id:
+            await message.answer("Cannot find your chat partner. They may have left.")
+            return
+        
+        # Get sender's name for notification
+        sender_name = await get_partner_nickname(session, user.id, group_id)
+        
+        # Forward the message to partner
+        try:
+            # First check if recipient needs a notification
+            sent_notification = await check_recipient_state(
+                bot=bot,
+                storage=state.storage,
+                recipient_telegram_id=partner.telegram_id,
+                sender_name=sender_name,
+                chat_id=chat_id,
+                partner_id=user.id,
+                is_group_chat=True,
+                group_id=group_id
+            )
+            
+            # Always send the message even if notification was sent
+            await bot.send_message(
+                chat_id=partner.telegram_id,
+                text=message.text
+            )
+            
+        except Exception as e:
+            logger.error(f"Error forwarding message in group chat: {e}")
+            await message.answer("Failed to send your message. The recipient may have blocked the bot.")
+    else:
+        # This is an anonymous chat session
+        chat_session_id = data.get("chat_session_id")
+        session_id = data.get("session_id")
+        match_id = data.get("match_id")
+        
+        if not chat_session_id:
+            await message.answer("You are not connected to anyone. Select a chat first.")
+            await state.clear()
+            return
+        
+        # Get chat session
+        chat_session = await get_by_session_id(session, session_id)
+        if not chat_session or chat_session.status != "active":
+            await message.answer("This chat is no longer active.")
+            await state.clear()
+            return
+        
+        # Get partner
+        partner = await user_repo.get(session, partner_id)
+        if not partner or not partner.telegram_id:
+            await message.answer("Cannot find your chat partner. They may have left.")
+            return
+        
+        # Get sender's name for notification
+        sender_name = await get_partner_nickname(session, user.id)
+        
+        # Save message to database
+        new_message = await chat_message_repo.create_message(
+            session,
+            chat_session_id=chat_session.id,
+            sender_id=user.id,
+            content_type="text",
+            text_content=message.text
+        )
+        
+        # Check if we need to update the history message for the sender
+        history_message_id = data.get("history_message_id")
+        if history_message_id:
+            try:
+                # Format the new message for display
+                timestamp = new_message.created_at.strftime("%H:%M")
+                formatted_message = f"[{timestamp}] You: {message.text}\n\n"
+                
+                # Get current history message
+                try:
+                    history_message = await bot.get_message(chat_id=user_id, message_id=history_message_id)
+                    
+                    # Check if message is too long for Telegram's limit
+                    if len(history_message.text + formatted_message) > 4000:
+                        # If too long, send a notification that history is now in multiple messages
+                        await message.answer(
+                            "Chat history is now split across multiple messages. "
+                            "Return to the menu and select this chat again to see full history."
+                        )
+                    else:
+                        # Add new message to history and update
+                        current_text = history_message.text
+                        # Find title and preserve it
+                        title_end = current_text.find("\n\n")
+                        if title_end != -1:
+                            title = current_text[:title_end + 2]  # Include the newlines
+                            current_content = current_text[title_end + 2:]
+                            new_content = formatted_message + current_content
+                            await bot.edit_message_text(
+                                chat_id=user_id,
+                                message_id=history_message_id,
+                                text=title + new_content,
+                                parse_mode="HTML",
+                                reply_markup=history_message.reply_markup
+                            )
+                except Exception as e:
+                    logger.error(f"Error updating history message: {e}")
+                    # Continue anyway, this is not critical
+            except Exception as e:
+                logger.error(f"Error handling history update: {e}")
+        
+        # Forward the message to partner
+        try:
+            # First check if recipient needs a notification
+            sent_notification = await check_recipient_state(
+                bot=bot,
+                storage=state.storage,
+                recipient_telegram_id=partner.telegram_id,
+                sender_name=sender_name,
+                chat_id=chat_session.id,
+                partner_id=user.id,
+                is_group_chat=False,
+                session_id=session_id,
+                match_id=match_id
+            )
+            
+            if not sent_notification:
+                # They're already in chat with this user, update their chat history too
+                partner_state_key = StorageKey(bot_id=bot.id, user_id=partner.telegram_id, chat_id=partner.telegram_id)
+                partner_data = await state.storage.get_data(key=partner_state_key)
+                partner_history_id = partner_data.get("history_message_id")
+                
+                if partner_history_id:
+                    try:
+                        # Format message for partner's view
+                        timestamp = new_message.created_at.strftime("%H:%M")
+                        partner_formatted_msg = f"[{timestamp}] {sender_name}: {message.text}\n\n"
+                        
+                        # Get current history message
+                        try:
+                            partner_history = await bot.get_message(
+                                chat_id=partner.telegram_id, 
+                                message_id=partner_history_id
+                            )
+                            
+                            # Check if message is too long
+                            if len(partner_history.text + partner_formatted_msg) > 4000:
+                                # Too long, don't update
+                                pass
+                            else:
+                                # Add new message to history and update
+                                current_text = partner_history.text
+                                # Find title and preserve it
+                                title_end = current_text.find("\n\n")
+                                if title_end != -1:
+                                    title = current_text[:title_end + 2]  # Include the newlines
+                                    current_content = current_text[title_end + 2:]
+                                    new_content = partner_formatted_msg + current_content
+                                    await bot.edit_message_text(
+                                        chat_id=partner.telegram_id,
+                                        message_id=partner_history_id,
+                                        text=title + new_content,
+                                        parse_mode="HTML",
+                                        reply_markup=partner_history.reply_markup
+                                    )
+                        except Exception as e:
+                            logger.error(f"Error updating partner history: {e}")
+                    except Exception as e:
+                        logger.error(f"Error handling partner history update: {e}")
+            
+            # Always send the message even if notification was sent
+            await bot.send_message(
+                chat_id=partner.telegram_id,
+                text=message.text
+            )
+            
+        except Exception as e:
+            logger.error(f"Error forwarding message to partner: {e}")
+            await message.answer("Failed to send your message. The recipient may have blocked the bot.") 
\ No newline at end of file
diff --git a/src/communicator_bot/repositories.py b/src/communicator_bot/repositories.py
index c438898..acff4a3 100644
--- a/src/communicator_bot/repositories.py
+++ b/src/communicator_bot/repositories.py
@@ -5,36 +5,29 @@ from dataclasses import dataclass
 from typing import List, Optional, Union, Any
 
 from src.db.models import (
-    User, Match, AnonymousChatSession, Chat,
-    ChatMessage, BlockedUser, GroupMember
+    User, Match, Chat,
+    ChatMessage, BlockedUser,
+    AnonymousChatSession
 )
 from src.db.repositories.user import user_repo
 from src.db.repositories.match_repo import get_match_between_users
-from src.db.repositories.chat_session_repo import (
-    get_by_session_id, update_status, get_active_session_for_user,
-    get_partner_id, create_chat_session
-)
 from src.db.repositories.chat_message_repo import chat_message_repo
 from src.db.repositories.blocked_user_repo import blocked_user_repo
 
 
 @dataclass
 class ChatInfo:
-    """Class to store chat information from either Chat or AnonymousChatSession."""
+    """Class to store chat information."""
     id: int
     initiator_id: int
     recipient_id: int
     status: str
-    is_group_chat: bool = False
-    group_id: Optional[int] = None
-    match_id: Optional[int] = None
     last_activity: Any = None
-    session_id: Optional[str] = None
 
 
 async def get_active_chats_for_user(session: AsyncSession, user_id: int) -> List[ChatInfo]:
     """
-    Get all active chats for a user from both Chat and AnonymousChatSession tables.
+    Get all active chats for a user from the Chat table.
     
     Args:
         session: Database session
@@ -43,19 +36,7 @@ async def get_active_chats_for_user(session: AsyncSession, user_id: int) -> List
     Returns:
         List of ChatInfo objects containing chat information
     """
-    # Query anonymous chat sessions
-    anon_query = select(AnonymousChatSession).where(
-        and_(
-            or_(
-                AnonymousChatSession.initiator_id == user_id,
-                AnonymousChatSession.recipient_id == user_id
-            ),
-            AnonymousChatSession.status == "active"
-        )
-    ).order_by(AnonymousChatSession.last_activity.desc())
-    
-    anon_result = await session.execute(anon_query)
-    anon_chats = anon_result.scalars().all()
+    from loguru import logger
     
     # Query regular chats
     chat_query = select(Chat).where(
@@ -70,39 +51,27 @@ async def get_active_chats_for_user(session: AsyncSession, user_id: int) -> List
     
     chat_result = await session.execute(chat_query)
     regular_chats = chat_result.scalars().all()
+    logger.info(f"Found {len(regular_chats)} chats for user {user_id}")
     
-    # Combine results into ChatInfo objects
+    # Convert to ChatInfo objects
     result = []
     
-    # Convert anonymous chat sessions
-    for chat in anon_chats:
-        result.append(ChatInfo(
-            id=chat.id,
-            initiator_id=chat.initiator_id,
-            recipient_id=chat.recipient_id,
-            status=chat.status,
-            is_group_chat=False,
-            match_id=chat.match_id,
-            last_activity=chat.last_activity,
-            session_id=chat.session_id
-        ))
-    
     # Convert regular chats
     for chat in regular_chats:
-        result.append(ChatInfo(
-            id=chat.id,
-            initiator_id=chat.initiator_id,
-            recipient_id=chat.recipient_id,
-            status=chat.status,
-            is_group_chat=True,
-            group_id=chat.group_id,
-            last_activity=chat.updated_at
-        ))
-    
-    # Sort by last activity (most recent first)
-    # This assumes last_activity and updated_at are comparable
-    result.sort(key=lambda x: x.last_activity if x.last_activity else 0, reverse=True)
+        try:
+            chat_info = ChatInfo(
+                id=chat.id,
+                initiator_id=chat.initiator_id,
+                recipient_id=chat.recipient_id,
+                status=chat.status,
+                last_activity=chat.updated_at
+            )
+            result.append(chat_info)
+            logger.info(f"Added chat: id={chat.id}")
+        except Exception as e:
+            logger.error(f"Error converting chat {chat.id}: {e}")
     
+    logger.info(f"Total active chats: {len(result)}")
     return result
 
 
@@ -178,77 +147,127 @@ async def get_unread_messages(session: AsyncSession, chat_id: int, user_id: int)
     return result.scalars().all()
 
 
-async def get_chat_session_by_match(session: AsyncSession, match_id: int) -> AnonymousChatSession:
+async def get_partner_nickname(session: AsyncSession, user_id: int) -> str:
     """
-    Get chat session by match ID.
+    Get nickname for a user, falling back to first_name if not available.
     
     Args:
         session: Database session
-        match_id: ID of the match
+        user_id: ID of the user
         
     Returns:
-        Chat session or None
+        Nickname or user's first name
     """
-    query = select(AnonymousChatSession).where(
-        and_(
-            AnonymousChatSession.match_id == match_id,
-            AnonymousChatSession.status == "active"
-        )
-    )
+    user = await user_repo.get(session, user_id)
+    if not user:
+        return "Unknown User"
     
-    result = await session.execute(query)
-    return result.scalar_one_or_none()
+    # Return user's first name or username as default
+    if user.first_name:
+        return user.first_name
+    elif user.username:
+        return user.username
+    else:
+        return f"User {user_id}"
 
 
-async def get_partner_nickname(session: AsyncSession, user_id: int, group_id: int = None) -> str:
+async def end_chat_session(session: AsyncSession, chat_id: int) -> bool:
     """
-    Get nickname for a user from GroupMember, falling back to first_name if not available.
+    End a chat session by setting its status to 'ended'.
     
     Args:
         session: Database session
-        user_id: ID of the user
-        group_id: Optional group ID to look for nickname
+        chat_id: ID of the chat session
         
     Returns:
-        Nickname or user's first name
+        True if successful, False otherwise
     """
-    user = await user_repo.get(session, user_id)
-    if not user:
-        return "Unknown User"
+    try:
+        chat = await session.get(Chat, chat_id)
+        if chat:
+            chat.status = "ended"
+            await session.commit()
+            return True
+    except Exception as e:
+        from loguru import logger
+        logger.error(f"Error ending chat session: {e}")
     
-    # Try to get nickname from any group
-    query = select(GroupMember).where(
-        GroupMember.user_id == user_id
-    )
+    return False
+
+
+async def get_unread_chat_summary(session: AsyncSession, user_id: int) -> List[dict]:
+    """
+    Get summary of unread messages for a user across all chats.
     
-    if group_id:
-        query = query.where(GroupMember.group_id == group_id)
+    Args:
+        session: Database session
+        user_id: ID of the user
+        
+    Returns:
+        List of dicts with chat information and unread count
+    """
+    # Get all active chats for user
+    all_chats = await get_active_chats_for_user(session, user_id)
     
-    result = await session.execute(query)
-    member = result.scalar_one_or_none()
+    result = []
+    for chat in all_chats:
+        # Get partner ID
+        partner_id = chat.recipient_id if chat.initiator_id == user_id else chat.initiator_id
+        
+        # Count unread messages
+        unread_count = await get_unread_message_count(session, chat.id, user_id)
+        
+        # Only include chats with unread messages
+        if unread_count > 0:
+            partner_name = await get_partner_nickname(
+                session, partner_id
+            )
+            
+            result.append({
+                "chat_id": chat.id,
+                "partner_id": partner_id,
+                "partner_name": partner_name,
+                "unread_count": unread_count,
+            })
     
-    if member and member.nickname:
-        return member.nickname
+    # Sort by unread count (highest first)
+    result.sort(key=lambda x: x["unread_count"], reverse=True)
     
-    # Fallback to user's first name
-    return f"{user.first_name} {user.last_name or ''}".strip()
+    return result
 
 
-async def end_chat_session(session: AsyncSession, chat_id: int) -> bool:
+async def get_chat_session_by_match(session: AsyncSession, match_id: int) -> Optional[AnonymousChatSession]:
     """
-    End a chat session.
+    Get an active chat session for a specific match.
     
     Args:
         session: Database session
-        chat_id: ID of the chat session
+        match_id: ID of the match
         
     Returns:
-        True if successful
+        AnonymousChatSession object if found, None otherwise
     """
-    chat = await session.get(AnonymousChatSession, chat_id)
-    if not chat:
-        return False
+    from loguru import logger
     
-    chat.status = "ended"
-    await session.commit()
-    return True 
\ No newline at end of file
+    logger.info(f"Looking for chat session with match_id={match_id}")
+    
+    try:
+        query = select(AnonymousChatSession).where(
+            and_(
+                AnonymousChatSession.match_id == match_id,
+                AnonymousChatSession.status == "active"
+            )
+        )
+        
+        result = await session.execute(query)
+        chat_session = result.scalars().first()
+        
+        if chat_session:
+            logger.info(f"Found chat session: id={chat_session.id}, session_id={chat_session.session_id}")
+        else:
+            logger.info(f"No active chat session found for match_id={match_id}")
+            
+        return chat_session
+    except Exception as e:
+        logger.error(f"Error fetching chat session by match: {e}")
+        return None 
\ No newline at end of file
diff --git a/src/communicator_bot/states.py b/src/communicator_bot/states.py
index ecbc08c..dc74a61 100644
--- a/src/communicator_bot/states.py
+++ b/src/communicator_bot/states.py
@@ -4,4 +4,6 @@ class ChatState(StatesGroup):
     waiting_for_nickname = State()
     waiting_for_partner = State()
     waiting_for_link_activation = State()
-    in_chat = State() 
\ No newline at end of file
+    in_chat = State()
+    selecting_chat = State()
+    managing_users = State() 
\ No newline at end of file
diff --git a/src/communicator_bot/user_management.py b/src/communicator_bot/user_management.py
new file mode 100644
index 0000000..ad1de5e
--- /dev/null
+++ b/src/communicator_bot/user_management.py
@@ -0,0 +1,361 @@
+"""
+User management functionality for the communicator bot.
+"""
+from aiogram import Bot, F, Router
+from aiogram.fsm.context import FSMContext
+from aiogram.types import Message, CallbackQuery
+from loguru import logger
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from src.db.repositories.user import user_repo
+from src.db.repositories.match_repo import get_match_between_users
+from src.db.repositories.chat_session_repo import update_status
+from src.db.repositories.chat_message_repo import chat_message_repo
+from src.db.repositories.blocked_user_repo import blocked_user_repo
+
+from .states import ChatState
+from .keyboards import (
+    get_select_user_to_manage_keyboard,
+    get_user_management_keyboard,
+    get_confirm_delete_keyboard,
+    get_confirm_block_keyboard,
+    get_back_to_menu_keyboard
+)
+from .repositories import (
+    get_active_chats_for_user,
+    get_partner_nickname
+)
+
+# Define placeholder for missing functions
+get_chat_session_by_match = None
+
+# Try to import the function if it exists
+try:
+    from .repositories import get_chat_session_by_match
+except ImportError:
+    logger.warning("get_chat_session_by_match not found in repositories. Some functionality may be limited.")
+    
+    # Define a placeholder function
+    async def get_chat_session_by_match(session, match_id):
+        logger.error(f"get_chat_session_by_match was called but is not implemented!")
+        return None
+
+from .chat_handlers import show_main_menu
+
+router = Router()
+
+# Manage users
+@router.message(F.text == "⚙️ Manage users")
+async def show_user_management(message: Message, state: FSMContext, session: AsyncSession):
+    """Display list of users to manage."""
+    user = await user_repo.get_by_telegram_id(session, message.from_user.id)
+    if not user:
+        await message.answer("You need to register in the main bot first.")
+        return
+        
+    # Get all active chats
+    active_chats = await get_active_chats_for_user(session, user.id)
+    
+    if not active_chats:
+        await message.answer(
+            "You don't have any active chats to manage.",
+            reply_markup=get_back_to_menu_keyboard()
+        )
+        return
+        
+    # Format users for keyboard
+    users_data = []
+    for chat in active_chats:
+        # Determine partner ID
+        partner_id = chat.recipient_id if chat.initiator_id == user.id else chat.initiator_id
+        partner = await user_repo.get(session, partner_id)
+        
+        if not partner:
+            continue
+            
+        # Get partner nickname
+        partner_name = await get_partner_nickname(session, partner_id)
+        
+        users_data.append({
+            "id": partner.id,
+            "name": partner_name
+        })
+    
+    await message.answer(
+        "Select a user to manage:",
+        reply_markup=get_select_user_to_manage_keyboard(users_data)
+    )
+    
+    await state.set_state(ChatState.managing_users)
+
+
+# User management selection callback
+@router.callback_query(F.data.startswith("manage:"))
+async def on_manage_user_selected(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
+    """Handle selecting a user to manage."""
+    await callback.answer()
+    
+    user = await user_repo.get_by_telegram_id(session, callback.from_user.id)
+    if not user:
+        await callback.message.answer("You need to register in the main bot first.")
+        return
+    
+    partner_id = int(callback.data.split(":")[1])
+    partner = await user_repo.get(session, partner_id)
+    
+    if not partner:
+        await callback.message.answer("Partner not found.")
+        return
+    
+    # Get partner nickname
+    partner_name = await get_partner_nickname(session, partner_id)
+    
+    await callback.message.edit_text(
+        f"Manage your relationship with {partner_name}:",
+        reply_markup=get_user_management_keyboard(partner_id)
+    )
+
+
+# Show username action
+@router.callback_query(F.data.startswith("show_username:"))
+async def on_show_username(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
+    """Reveal the username of a chat partner."""
+    await callback.answer()
+    
+    user = await user_repo.get_by_telegram_id(session, callback.from_user.id)
+    if not user:
+        await callback.message.answer("You need to register in the main bot first.")
+        return
+    
+    partner_id = int(callback.data.split(":")[1])
+    partner = await user_repo.get(session, partner_id)
+    
+    if not partner:
+        await callback.message.answer("Partner not found.")
+        return
+    
+    # Get partner nickname
+    partner_name = await get_partner_nickname(session, partner_id)
+    
+    # Get partner username
+    username = f"@{partner.username}" if partner.username else "No username set"
+    
+    await callback.message.edit_text(
+        f"User information for {partner_name}:\n\n"
+        f"Name: {partner.first_name} {partner.last_name or ''}\n"
+        f"Username: {username}\n\n"
+        f"You can now contact them directly on Telegram.",
+        reply_markup=get_user_management_keyboard(partner_id)
+    )
+    
+    # Notify the partner
+    partner_tg_id = partner.telegram_id
+    if partner_tg_id:
+        try:
+            bot = callback.bot
+            await bot.send_message(
+                partner_tg_id,
+                f"{user.first_name} has viewed your Telegram username."
+            )
+        except Exception as e:
+            logger.error(f"Failed to notify user {partner_tg_id}: {e}")
+
+
+# Delete match confirmation request
+@router.callback_query(F.data.startswith("delete_match:"))
+async def on_delete_match_request(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
+    """Show confirmation for deleting a match."""
+    await callback.answer()
+    
+    partner_id = int(callback.data.split(":")[1])
+    partner = await user_repo.get(session, partner_id)
+    
+    if not partner:
+        await callback.message.answer("Partner not found.")
+        return
+    
+    # Get partner nickname
+    partner_name = await get_partner_nickname(session, partner_id)
+    
+    await callback.message.edit_text(
+        f"Are you sure you want to delete your match with {partner_name}?\n\n"
+        "This will remove your chat history and you won't be matched again.",
+        reply_markup=get_confirm_delete_keyboard(partner_id)
+    )
+
+
+# Block user confirmation request
+@router.callback_query(F.data.startswith("block_user:"))
+async def on_block_user_request(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
+    """Show confirmation for blocking a user."""
+    await callback.answer()
+    
+    partner_id = int(callback.data.split(":")[1])
+    partner = await user_repo.get(session, partner_id)
+    
+    if not partner:
+        await callback.message.answer("Partner not found.")
+        return
+    
+    # Get partner nickname
+    partner_name = await get_partner_nickname(session, partner_id)
+    
+    await callback.message.edit_text(
+        f"Are you sure you want to block {partner_name}?\n\n"
+        "They won't be able to contact you, and you won't be matched again.",
+        reply_markup=get_confirm_block_keyboard(partner_id)
+    )
+
+
+# Confirm delete match
+@router.callback_query(F.data.startswith("confirm_delete:"))
+async def on_confirm_delete(callback: CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
+    """Handle confirmation to delete a match."""
+    await callback.answer()
+    
+    user = await user_repo.get_by_telegram_id(session, callback.from_user.id)
+    if not user:
+        await callback.message.answer("You need to register in the main bot first.")
+        return
+    
+    partner_id = int(callback.data.split(":")[1])
+    partner = await user_repo.get(session, partner_id)
+    
+    if not partner:
+        await callback.message.answer("Partner not found.")
+        return
+    
+    # Find the match
+    match = await get_match_between_users(session, user.id, partner_id)
+    if not match:
+        await callback.message.answer("No match found with this user.")
+        return
+    
+    # Find the chat session
+    chat_session = await get_chat_session_by_match(session, match.id)
+    
+    if chat_session:
+        # End the chat session
+        await update_status(session, chat_session.id, "ended", set_ended=True)
+        
+        # Delete chat messages
+        await chat_message_repo.delete_messages_for_chat(session, chat_session.id)
+    
+    # Get partner nickname
+    partner_name = await get_partner_nickname(session, partner_id)
+    
+    await callback.message.edit_text(
+        f"Match with {partner_name} has been deleted.\n"
+        "Chat history has been cleared.",
+        reply_markup=None
+    )
+    
+    # Notify partner
+    partner_tg_id = partner.telegram_id
+    if partner_tg_id:
+        try:
+            await bot.send_message(
+                partner_tg_id,
+                f"{user.first_name} has ended your match."
+            )
+        except Exception as e:
+            logger.error(f"Failed to notify user {partner_tg_id}: {e}")
+    
+    # Return to main menu
+    await show_main_menu(callback.message, state, session)
+
+
+# Confirm block user
+@router.callback_query(F.data.startswith("confirm_block:"))
+async def on_confirm_block(callback: CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
+    """Handle confirmation to block a user."""
+    await callback.answer()
+    
+    user = await user_repo.get_by_telegram_id(session, callback.from_user.id)
+    if not user:
+        await callback.message.answer("You need to register in the main bot first.")
+        return
+    
+    partner_id = int(callback.data.split(":")[1])
+    partner = await user_repo.get(session, partner_id)
+    
+    if not partner:
+        await callback.message.answer("Partner not found.")
+        return
+    
+    # Block the user
+    await blocked_user_repo.block_user(session, user.id, partner_id)
+    
+    # Find the match
+    match = await get_match_between_users(session, user.id, partner_id)
+    
+    if match:
+        # Find the chat session
+        chat_session = await get_chat_session_by_match(session, match.id)
+        
+        if chat_session:
+            # End the chat session
+            await update_status(session, chat_session.id, "ended", set_ended=True)
+            
+            # Delete chat messages
+            await chat_message_repo.delete_messages_for_chat(session, chat_session.id)
+    
+    # Get partner nickname
+    partner_name = await get_partner_nickname(session, partner_id)
+    
+    await callback.message.edit_text(
+        f"{partner_name} has been blocked.\n"
+        "They won't be able to contact you, and you won't be matched again.",
+        reply_markup=None
+    )
+    
+    # Return to main menu
+    await show_main_menu(callback.message, state, session)
+
+
+# Back to menu from callback
+@router.callback_query(F.data == "back_to_menu")
+async def on_back_to_menu(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
+    """Handle back to menu button click."""
+    await callback.answer()
+    await show_main_menu(callback.message, state, session)
+
+
+# Manage users page navigation
+@router.callback_query(F.data.startswith("manage_page:"))
+async def on_manage_page_change(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
+    """Handle pagination for user management."""
+    await callback.answer()
+    
+    page = int(callback.data.split(":")[1])
+    
+    user = await user_repo.get_by_telegram_id(session, callback.from_user.id)
+    if not user:
+        await callback.message.answer("You need to register in the main bot first.")
+        return
+        
+    # Get all active chats
+    active_chats = await get_active_chats_for_user(session, user.id)
+    
+    # Format users for keyboard
+    users_data = []
+    for chat in active_chats:
+        # Determine partner ID
+        partner_id = chat.recipient_id if chat.initiator_id == user.id else chat.initiator_id
+        partner = await user_repo.get(session, partner_id)
+        
+        if not partner:
+            continue
+            
+        # Get partner nickname
+        partner_name = await get_partner_nickname(session, partner_id)
+        
+        users_data.append({
+            "id": partner.id,
+            "name": partner_name
+        })
+    
+    await callback.message.edit_text(
+        "Select a user to manage:",
+        reply_markup=get_select_user_to_manage_keyboard(users_data, page=page)
+    ) 
\ No newline at end of file
diff --git a/src/core/config.py b/src/core/config.py
index 6d75519..eca105f 100644
--- a/src/core/config.py
+++ b/src/core/config.py
@@ -1,5 +1,5 @@
 from functools import lru_cache
-from typing import List
+from typing import List, Optional, Union, Any
 
 from loguru import logger
 from pydantic_settings import BaseSettings
@@ -13,41 +13,65 @@ class Settings(BaseSettings):
     app_name: str = "Allkinds"
     
     # Bot specific settings (now centralized)
-    BOT_TOKEN: str
-    COMMUNICATOR_BOT_TOKEN: str
+    BOT_TOKEN: str = "dummy_token"  # Default prevents validation error
+    COMMUNICATOR_BOT_TOKEN: str = "dummy_token"  # Default prevents validation error
     # ADMIN_IDS should hold the final list of ints
-    ADMIN_IDS: List[int] # Changed type hint to List[int]
+    ADMIN_IDS: List[int] = [123456789]  # Default prevents validation error
     COMMUNICATOR_BOT_USERNAME: str = Field(default="", alias='COMMUNICATOR_BOT_USERNAME')
 
     @field_validator('ADMIN_IDS', mode='before')
     @classmethod
-    def _parse_admin_ids(cls, v: str | int | List[int]) -> List[int]: # Accept int as well
-        """Parse ADMIN_IDS string or int from .env into a list of integers."""
+    def _parse_admin_ids(cls, v: Any) -> List[int]:
+        """Parse ADMIN_IDS from various formats into a list of integers."""
+        logger.info(f"Parsing ADMIN_IDS from value type: {type(v)}")
+        
+        # Already a list, just return it
         if isinstance(v, list):
-             return v
+            logger.info(f"ADMIN_IDS is already a list: {v}")
+            return v
+        
+        # Single integer value
         if isinstance(v, int):
-            # Handle case where only one ID is provided as an int
             logger.info(f"Received single admin ID as int: {v}")
             return [v]
-        if not isinstance(v, str):
-             logger.warning(f"Unexpected type for ADMIN_IDS validation: {type(v)}")
-             return []
-        try:
-            # Expecting comma-separated string like "123,456"
-            return [int(id_str.strip()) for id_str in v.split(',') if id_str.strip().isdigit()]
-        except Exception as e:
-            logger.error(f"Failed to parse ADMIN_IDS string '{v}': {e}")
-            return []
-
-    # Property to easily access the parsed list (REMOVED as ADMIN_IDS is the list now)
-    # @property
-    # def admin_ids_list(self) -> List[int]:
-    #     if isinstance(self.ADMIN_IDS, list):
-    #          return self.ADMIN_IDS
-    #     return []
+        
+        # None or empty value, return default
+        if not v:
+            logger.warning("Empty ADMIN_IDS, using default")
+            return [123456789]  # Default admin ID
+        
+        # Handle string values
+        if isinstance(v, str):
+            try:
+                # Try parsing as comma-separated list
+                if ',' in v:
+                    logger.info(f"Parsing comma-separated ADMIN_IDS: {v}")
+                    return [int(id_str.strip()) for id_str in v.split(',') if id_str.strip().isdigit()]
+                
+                # Try parsing as a single number
+                if v.strip().isdigit():
+                    logger.info(f"Parsing single ADMIN_ID string: {v}")
+                    return [int(v.strip())]
+                
+                # Try parsing as JSON array if it looks like one
+                if v.strip().startswith('[') and v.strip().endswith(']'):
+                    logger.info(f"Parsing JSON array ADMIN_IDS: {v}")
+                    import json
+                    try:
+                        ids = json.loads(v)
+                        if isinstance(ids, list):
+                            return [int(id_val) for id_val in ids if isinstance(id_val, (int, str)) and (isinstance(id_val, int) or id_val.isdigit())]
+                    except Exception as e:
+                        logger.error(f"Failed to parse ADMIN_IDS as JSON: {e}")
+            except Exception as e:
+                logger.error(f"Failed to parse ADMIN_IDS string '{v}': {e}")
+        
+        # If we get here, something went wrong, return default
+        logger.warning(f"Could not properly parse ADMIN_IDS, using default. Value was: {v} (type: {type(v)})")
+        return [123456789]  # Default admin ID
 
     # Database settings
-    db_url: str = Field(default="sqlite+aiosqlite:///./allkinds.db", alias='DB_URL') # Use alias
+    db_url: str = Field(default="sqlite+aiosqlite:///./allkinds.db", alias='DATABASE_URL') # Use alias for Railway compatibility
     
     # OpenAI settings
     openai_api_key: str = Field(default="", alias='OPENAI_API_KEY')
diff --git a/src/db/models/group_member.py b/src/db/models/group_member.py
index d5d510d..48e9bc5 100644
--- a/src/db/models/group_member.py
+++ b/src/db/models/group_member.py
@@ -30,6 +30,10 @@ class GroupMember(Base):
         default=MemberRole.MEMBER,
     )
     
+    # Onboarding profile data
+    nickname: Mapped[str] = mapped_column(String(32), nullable=True)
+    photo_file_id: Mapped[str] = mapped_column(String(255), nullable=True)
+    
     # Timestamps
     joined_at: Mapped[datetime] = mapped_column(
         DateTime, default=datetime.utcnow
diff --git a/src/db/repositories/answer.py b/src/db/repositories/answer.py
index 205bcca..9d50b71 100644
--- a/src/db/repositories/answer.py
+++ b/src/db/repositories/answer.py
@@ -1,5 +1,6 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 from sqlalchemy import select
+from loguru import logger
 
 from src.db.models import Answer, Question
 from src.db.repositories.base import BaseRepository
@@ -11,54 +12,115 @@ class AnswerRepository(BaseRepository[Answer]):
 
     async def get_answer(self, session: AsyncSession, user_id: int, question_id: int) -> Answer | None:
         """Get a specific answer by user_id and question_id."""
-        query = select(Answer).where(
-            Answer.user_id == user_id,
-            Answer.question_id == question_id
-        )
-        result = await session.execute(query)
-        return result.scalar_one_or_none()
+        try:
+            # Ensure session is refreshed before the query
+            await session.commit()  # Commit any pending changes
+            
+            query = select(Answer).where(
+                Answer.user_id == user_id,
+                Answer.question_id == question_id
+            )
+            result = await session.execute(query)
+            answer = result.scalar_one_or_none()
+            
+            logger.info(f"Retrieved answer for user {user_id}, question {question_id}: {answer is not None}")
+            return answer
+        except Exception as e:
+            logger.error(f"Error in get_answer for user {user_id}, question {question_id}: {e}")
+            return None
 
     async def save_answer(
         self, session: AsyncSession, user_id: int, question_id: int, answer_type: str, value: int
     ) -> Answer:
-        """Saves or updates a user's answer to a question."""
-        # Check if answer already exists
-        existing_answer = await self.get_by_attribute(
-            session, 
-            expression=(Answer.user_id == user_id) & (Answer.question_id == question_id)
-        ) # Need to adjust get_by_attribute for complex conditions or create a specific method
-
-        data = {
-            "user_id": user_id,
-            "question_id": question_id,
-            "answer_type": answer_type,
-            "value": value
-        }
-
-        if existing_answer:
-            # Update existing answer
-            updated_answer = await self.update(session, existing_answer.id, data)
-            if not updated_answer: # Handle potential update failure
-                 raise Exception("Failed to update existing answer")
-            return updated_answer
-        else:
-            # Create new answer
-            return await self.create(session, data)
+        """Saves or updates a user's answer to a question with robust error handling and transaction management."""
+        try:
+            # First commit any pending changes to ensure a clean session state
+            await session.commit()
+            
+            # Check if answer already exists with a fresh query
+            logger.info(f"Checking if answer exists for user {user_id}, question {question_id}")
+            existing_answer = await self.get_answer(session, user_id, question_id)
+            
+            data = {
+                "user_id": user_id,
+                "question_id": question_id,
+                "answer_type": answer_type,
+                "value": value
+            }
+            
+            logger.info(f"Saving answer for user {user_id}, question {question_id}, type: {answer_type}, value: {value}")
+            
+            if existing_answer:
+                logger.info(f"Updating existing answer {existing_answer.id} for user {user_id}, question {question_id}")
+                # Update existing answer
+                updated_answer = await self.update(session, existing_answer.id, data)
+                if not updated_answer:
+                    logger.error(f"Failed to update existing answer {existing_answer.id}")
+                    raise Exception("Failed to update existing answer")
+                
+                # Explicitly commit the update
+                try:
+                    await session.commit()
+                    logger.info(f"Successfully committed answer update for user {user_id}, question {question_id}")
+                except Exception as commit_error:
+                    logger.error(f"Failed to commit answer update: {commit_error}", exc_info=True)
+                    await session.rollback()
+                    raise
+                
+                return updated_answer
+            else:
+                logger.info(f"Creating new answer for user {user_id}, question {question_id}")
+                # Create new answer
+                new_answer = await self.create(session, data)
+                
+                # Explicitly commit the creation
+                try:
+                    await session.commit()
+                    logger.info(f"Successfully committed new answer for user {user_id}, question {question_id}")
+                except Exception as commit_error:
+                    logger.error(f"Failed to commit new answer: {commit_error}", exc_info=True)
+                    await session.rollback()
+                    raise
+                
+                return new_answer
+        except Exception as e:
+            logger.error(f"Error in save_answer for user {user_id}, question {question_id}: {e}", exc_info=True)
+            # Ensure rollback on any error
+            try:
+                await session.rollback()
+            except Exception as rollback_error:
+                logger.error(f"Error during rollback: {rollback_error}")
+            
+            # Re-raise to notify caller
+            raise
 
     async def get_user_answers_for_group(self, session: AsyncSession, user_id: int, group_id: int) -> list[Answer]:
-        """Get all answers from a user for questions in a specific group."""
-        query = select(Answer).join(
-            Question, Answer.question_id == Question.id
-        ).where(
-            Answer.user_id == user_id,
-            Question.group_id == group_id
-        ).order_by(Answer.created_at.desc())
-        
-        result = await session.execute(query)
-        return result.scalars().all()
+        """Get all answers from a user for questions in a specific group with improved reliability."""
+        try:
+            # Commit any pending changes to ensure we get the latest data
+            await session.commit()
+            
+            # Fetch answers with a single optimized query
+            query = select(Answer).join(
+                Question, Answer.question_id == Question.id
+            ).where(
+                Answer.user_id == user_id,
+                Question.group_id == group_id
+            ).order_by(Answer.created_at.desc())
+            
+            logger.info(f"Fetching answers for user {user_id} in group {group_id}")
+            result = await session.execute(query)
+            answers = result.scalars().all()
+            
+            logger.info(f"Found {len(answers)} answers for user {user_id} in group {group_id}")
+            return answers
+        except Exception as e:
+            logger.error(f"Error in get_user_answers_for_group for user {user_id}, group {group_id}: {e}", exc_info=True)
+            return []
 
     async def get_answers_for_user_in_group(self, session: AsyncSession, user_id: int, group_id: int) -> list[Answer]:
         """Alias for get_user_answers_for_group for backward compatibility."""
         return await self.get_user_answers_for_group(session, user_id, group_id)
 
+
 answer_repo = AnswerRepository() 
\ No newline at end of file
diff --git a/start_communicator_bot.py b/start_communicator_bot.py
index a45a453..2eae8ec 100755
--- a/start_communicator_bot.py
+++ b/start_communicator_bot.py
@@ -24,6 +24,27 @@ if not COMMUNICATOR_BOT_TOKEN:
 # Make sure we're in the correct directory
 print(f"Starting communicator bot from {script_dir}")
 
+# Run database migrations
+print("Running database migrations...")
+try:
+    migration_result = subprocess.run(
+        [sys.executable, "run_communicator_migrations.py"],
+        capture_output=True,
+        text=True,
+        check=True
+    )
+    print(migration_result.stdout)
+    if migration_result.returncode != 0:
+        print(f"❌ Migration failed: {migration_result.stderr}")
+        sys.exit(1)
+    print("✅ Database migrations completed")
+except subprocess.CalledProcessError as e:
+    print(f"❌ Migration failed with error code {e.returncode}: {e.stderr}")
+    sys.exit(1)
+except Exception as e:
+    print(f"❌ Migration failed: {str(e)}")
+    sys.exit(1)
+
 # Reset the webhook to ensure clean start
 print("Resetting Telegram webhook...")
 try:
@@ -67,7 +88,7 @@ except Exception as e:
 try:
     print("Starting new communicator bot instance...")
     # Use subprocess to start the bot and detach
-    with open("communicator_bot.log", "a") as logfile:
+    with open("communicator_bot_new.log", "a") as logfile:
         subprocess.Popen(
             [sys.executable, "-m", "src.communicator_bot.main"],
             stdout=logfile,
diff --git a/states_fixed.py b/states_fixed.py
new file mode 100644
index 0000000..547bd89
--- /dev/null
+++ b/states_fixed.py
@@ -0,0 +1,34 @@
+from aiogram.fsm.state import State, StatesGroup
+
+
+class TeamCreation(StatesGroup):
+    """States for team creation flow."""
+    waiting_for_name = State()
+    waiting_for_description = State()
+    confirm_creation = State()
+
+
+class TeamJoining(StatesGroup):
+    """States for team joining flow."""
+    waiting_for_code = State()
+
+
+class QuestionFlow(StatesGroup):
+    """States for question answering flow."""
+    viewing_question = State()
+    answering = State()
+    creating_question = State()
+    reviewing_question = State()
+    choosing_correction = State()
+    confirming_delete = State()
+
+
+class MatchingStates(StatesGroup):
+    finding_matches = State()
+    waiting_for_chat_confirmation = State()
+
+
+class GroupOnboarding(StatesGroup):
+    """States for onboarding a user to a group (nickname, photo)."""
+    waiting_for_nickname = State()
+    waiting_for_photo = State() 
\ No newline at end of file
diff --git a/temp_duplicate_check.py b/temp_duplicate_check.py
new file mode 100644
index 0000000..bf7148e
--- /dev/null
+++ b/temp_duplicate_check.py
@@ -0,0 +1,103 @@
+import os
+import sys
+import asyncio
+from collections import defaultdict
+import difflib
+from sqlalchemy import select, func, text
+from loguru import logger
+
+# Add project root to path for imports
+sys.path.append(os.path.dirname(os.path.abspath(__file__)))
+
+from src.db.base import async_session_factory
+from src.db.models.question import Question
+from src.db.models.group import Group
+
+async def analyze_duplicate_questions():
+    """Analyze and report potential duplicate questions in the database."""
+    async with async_session_factory() as session:
+        # Get all active questions
+        query = select(Question).where(Question.is_active == True)
+        result = await session.execute(query)
+        questions = result.scalars().all()
+        
+        print(f"\nTotal active questions: {len(questions)}")
+        
+        # 1. Check for exact duplicates (case insensitive)
+        exact_duplicates = defaultdict(list)
+        for q in questions:
+            normalized_text = q.text.lower().strip()
+            exact_duplicates[normalized_text].append(q)
+        
+        # Filter to keep only those with multiple entries
+        exact_duplicates = {text: qs for text, qs in exact_duplicates.items() if len(qs) > 1}
+        
+        if exact_duplicates:
+            print("\n===== EXACT DUPLICATES =====")
+            for text, duplicates in exact_duplicates.items():
+                print(f"\nDuplicate text: \"{text}\"")
+                for q in duplicates:
+                    # Get group name
+                    group_query = select(Group).where(Group.id == q.group_id)
+                    group_result = await session.execute(group_query)
+                    group = group_result.scalar_one_or_none()
+                    group_name = group.name if group else "Unknown Group"
+                    
+                    print(f"  ID: {q.id}, Group: {group_name} (ID: {q.group_id}), Author: {q.author_id}, Created: {q.created_at}")
+        else:
+            print("\nNo exact duplicates found.")
+        
+        # 2. Check for similar questions (fuzzy matching)
+        similarity_threshold = 0.85  # Adjust as needed
+        similar_questions = []
+        
+        # Compare each question with all others
+        for i, q1 in enumerate(questions):
+            for j, q2 in enumerate(questions[i+1:], i+1):
+                # Skip same questions or questions from different groups
+                if q1.id == q2.id or q1.group_id != q2.group_id:
+                    continue
+                
+                # Calculate similarity ratio
+                similarity = difflib.SequenceMatcher(None, 
+                                                    q1.text.lower().strip(), 
+                                                    q2.text.lower().strip()).ratio()
+                
+                if similarity >= similarity_threshold:
+                    similar_questions.append((q1, q2, similarity))
+        
+        if similar_questions:
+            print("\n===== SIMILAR QUESTIONS =====")
+            for q1, q2, similarity in sorted(similar_questions, key=lambda x: x[2], reverse=True):
+                # Get group name
+                group_query = select(Group).where(Group.id == q1.group_id)
+                group_result = await session.execute(group_query)
+                group = group_result.scalar_one_or_none()
+                group_name = group.name if group else "Unknown Group"
+                
+                print(f"\nSimilarity: {similarity:.2f} in group: {group_name} (ID: {q1.group_id})")
+                print(f"  Question 1 (ID: {q1.id}): \"{q1.text}\"")
+                print(f"  Question 2 (ID: {q2.id}): \"{q2.text}\"")
+        else:
+            print("\nNo similar questions found.")
+        
+        # 3. Analyze questions by group
+        group_query = select(Group)
+        group_result = await session.execute(group_query)
+        groups = group_result.scalars().all()
+        
+        print("\n===== QUESTIONS BY GROUP =====")
+        for group in groups:
+            # Count questions in this group
+            count_query = select(func.count()).select_from(Question).where(
+                Question.group_id == group.id,
+                Question.is_active == True
+            )
+            count_result = await session.execute(count_query)
+            question_count = count_result.scalar_one()
+            
+            print(f"\nGroup: {group.name} (ID: {group.id})")
+            print(f"  Questions: {question_count}")
+
+if __name__ == "__main__":
+    asyncio.run(analyze_duplicate_questions()) 
\ No newline at end of file
diff --git a/temp_line.txt.bak b/temp_line.txt.bak
new file mode 100644
index 0000000..7578727
--- /dev/null
+++ b/temp_line.txt.bak
@@ -0,0 +1 @@
+        logger.exception("Main bot exited due to an error:")
diff --git a/test_bot.py b/test_bot.py
new file mode 100644
index 0000000..ee6cb8e
--- /dev/null
+++ b/test_bot.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+import asyncio
+import logging
+import base64
+import os
+from aiogram import Bot, Dispatcher, types
+from aiogram.filters import Command
+from dotenv import load_dotenv
+
+# Configure logging
+logging.basicConfig(level=logging.INFO)
+logger = logging.getLogger(__name__)
+
+# Load environment variables
+load_dotenv()
+BOT_TOKEN = os.getenv("BOT_TOKEN")
+
+# Create bot and dispatcher
+bot = Bot(token=BOT_TOKEN)
+dp = Dispatcher()
+
+@dp.message(Command("start"))
+async def cmd_start(message: types.Message):
+    """Handle the /start command"""
+    logger.info(f"Received /start command from user {message.from_user.id}")
+    
+    args = message.text.split()[1:] if len(message.text.split()) > 1 else None
+    
+    if args:
+        arg = args[0]
+        logger.info(f"Command has args: {arg}")
+        
+        # Try to decode as base64
+        try:
+            decoded = base64.b64decode(arg).decode('utf-8')
+            logger.info(f"Decoded from base64: {decoded}")
+            
+            if decoded.startswith('g') and decoded[1:].isdigit():
+                group_id = int(decoded[1:])
+                await message.answer(f"Deep link detected! Would you like to join group {group_id}?")
+                return
+        except Exception as e:
+            logger.info(f"Not base64: {e}")
+        
+        # Try direct format
+        if arg.startswith('g') and arg[1:].isdigit():
+            group_id = int(arg[1:])
+            await message.answer(f"Direct group link detected! Would you like to join group {group_id}?")
+            return
+            
+        await message.answer(f"Received args: {arg}")
+    else:
+        await message.answer("Welcome to the bot! Send /start ZzE to test deep link.")
+
+@dp.message()
+async def echo(message: types.Message):
+    """Echo all messages except commands"""
+    logger.info(f"Received message: {message.text}")
+    await message.answer(f"You said: {message.text}")
+
+async def main():
+    await dp.start_polling(bot)
+
+if __name__ == "__main__":
+    logger.info("Starting test bot...")
+    asyncio.run(main()) 
\ No newline at end of file
diff --git a/test_telegram.py b/test_telegram.py
new file mode 100644
index 0000000..cd5cc75
--- /dev/null
+++ b/test_telegram.py
@@ -0,0 +1,105 @@
+#!/usr/bin/env python
+"""
+Telegram Bot Test Tool
+
+This script tests the bot's ability to send and receive messages from Telegram.
+Usage:
+    python test_telegram.py                       # Check bot info
+    python test_telegram.py --send <user_id>      # Send a test message to a user
+"""
+
+import requests
+import os
+import sys
+import argparse
+import json
+import time
+
+def get_token():
+    """Get the bot token from environment variables."""
+    token = os.environ.get('TELEGRAM_BOT_TOKEN')
+    if not token:
+        print("ERROR: TELEGRAM_BOT_TOKEN environment variable not found.")
+        print("Please set it before running this script.")
+        sys.exit(1)
+    return token
+
+def get_bot_info(token):
+    """Get information about the bot."""
+    url = f"https://api.telegram.org/bot{token}/getMe"
+    
+    try:
+        response = requests.get(url)
+        data = response.json()
+        
+        if not response.ok:
+            print(f"Error: {data.get('description', 'Unknown error')}")
+            return False
+        
+        result = data.get('result', {})
+        
+        print("\n=== BOT INFO ===")
+        print(f"ID: {result.get('id')}")
+        print(f"Name: {result.get('first_name')}")
+        print(f"Username: @{result.get('username')}")
+        print(f"Can join groups: {result.get('can_join_groups', False)}")
+        print(f"Can read all group messages: {result.get('can_read_all_group_messages', False)}")
+        print(f"Supports inline queries: {result.get('supports_inline_queries', False)}")
+        
+        return True
+            
+    except Exception as e:
+        print(f"Error getting bot info: {e}")
+        return False
+
+def send_test_message(token, chat_id):
+    """Send a test message to a chat."""
+    url = f"https://api.telegram.org/bot{token}/sendMessage"
+    
+    try:
+        timestamp = int(time.time())
+        message = f"Test message from Railway deployment at {timestamp}"
+        
+        params = {
+            'chat_id': chat_id,
+            'text': message,
+            'parse_mode': 'Markdown'
+        }
+        
+        print(f"Sending message to chat ID: {chat_id}")
+        response = requests.post(url, params=params)
+        data = response.json()
+        
+        if not response.ok:
+            print(f"Error: {data.get('description', 'Unknown error')}")
+            return False
+        
+        print("Message sent successfully!")
+        print(f"Chat ID: {data['result']['chat']['id']}")
+        print(f"Message ID: {data['result']['message_id']}")
+        return True
+            
+    except Exception as e:
+        print(f"Error sending message: {e}")
+        return False
+
+def main():
+    parser = argparse.ArgumentParser(description='Telegram Bot Test Tool')
+    
+    parser.add_argument('--send', metavar='CHAT_ID', help='Send a test message to a chat ID')
+    parser.add_argument('--keyboard', action='store_true', help='Include inline keyboard in test message')
+    
+    args = parser.parse_args()
+    
+    # Get token
+    token = get_token()
+    
+    # Get bot info
+    get_bot_info(token)
+    
+    # Process actions
+    if args.send:
+        send_test_message(token, args.send)
+
+if __name__ == "__main__":
+    main() 
\ No newline at end of file
